<?xml version="1.0"?>
<configurator>
  <callback prefix="emberAf" postfix="Callback">
    <function id="READ_ATTRIBUTES_RESPONSE" name="Read Attributes Response" returnType="bool">
      <description>
        This function is called by the application framework when a Read Attributes Response command is received from an external device.  The application should return true if the message was processed or false if it was not.
      </description>
      <arg name="clusterId" type="EmberAfClusterId" description="The cluster identifier of this response." />
      <arg name="buffer"    type="uint8_t *"          description="Buffer containing the list of read attribute status records." />
      <arg name="bufLen"    type="uint16_t"           description="The length in bytes of the list." />
      <codeForStub>
        return false;
      </codeForStub>
    </function>
    <function id="WRITE_ATTRIBUTES_RESPONSE" name="Write Attributes Response" returnType="bool">
      <description>
        This function is called by the application framework when a Write Attributes Response command is received from an external device.  The application should return true if the message was processed or false if it was not.
      </description>
      <arg name="clusterId" type="EmberAfClusterId" description="The cluster identifier of this response." />
      <arg name="buffer"    type="uint8_t *"          description="Buffer containing the list of write attribute status records." />
      <arg name="bufLen"    type="uint16_t"           description="The length in bytes of the list." />
      <codeForStub>
        return false;
      </codeForStub>
    </function>
    <function id="CONFIGURE_REPORTING_RESPONSE" name="Configure Reporting Response" returnType="bool">
      <description>
        This function is called by the application framework when a Configure Reporting Response command is received from an external device.  The application should return true if the message was processed or false if it was not.
      </description>
      <arg name="clusterId" type="EmberAfClusterId" description="The cluster identifier of this response." />
      <arg name="buffer"    type="uint8_t *"          description="Buffer containing the list of attribute status records." />
      <arg name="bufLen"    type="uint16_t"           description="The length in bytes of the list." />
      <codeForStub>
        return false;
      </codeForStub>
    </function>
    <function id="READ_REPORTING_CONFIGURATION_RESPONSE" name="Read Reporting Configuration Response" returnType="bool">
      <description>
        This function is called by the application framework when a Read Reporting Configuration Response command is received from an external device.  The application should return true if the message was processed or false if it was not.
      </description>
      <arg name="clusterId" type="EmberAfClusterId" description="The cluster identifier of this response." />
      <arg name="buffer"    type="uint8_t *"          description="Buffer containing the list of attribute reporting configuration records." />
      <arg name="bufLen"    type="uint16_t"           description="The length in bytes of the list." />
      <codeForStub>
        return false;
      </codeForStub>
    </function>
    <function id="REPORT_ATTRIBUTES_RESPONSE" name="Report Attributes" returnType="bool">
      <description>
        This function is called by the application framework when a Report Attributes command is received from an external device.  The application should return true if the message was processed or false if it was not.
      </description>
      <arg name="clusterId" type="EmberAfClusterId" description="The cluster identifier of this command." />
      <arg name="buffer"    type="uint8_t *"          description="Buffer containing the list of attribute report records." />
      <arg name="bufLen"    type="uint16_t"           description="The length in bytes of the list." />
      <codeForStub>
        return false;
      </codeForStub>
    </function>
    <function id="DEFAULT_RESPONSE" name="Default Response" returnType="bool">
      <description>
        This function is called by the application framework when a Default Response command is received from an external device.  The application should return true if the message was processed or false if it was not.
      </description>
      <arg name="clusterId" type="EmberAfClusterId" description="The cluster identifier of this response." />
      <arg name="commandId" type="uint8_t"            description="The command identifier to which this is a response." />
      <arg name="status"    type="EmberAfStatus"    description="Specifies either SUCCESS or the nature of the error that was detected in the received command." />
      <codeForStub>
        return false;
      </codeForStub>
    </function>
    <function id="DISCOVER_ATTRIBUTES_RESPONSE" name="Discover Attributes Response" returnType="bool">
      <description>
        This function is called by the application framework when a Discover Attributes Response or Discover Attributes Extended Response command is received from an external device.  The Discover Attributes Response command contains a bool indicating if discovery is complete and a list of zero or more attribute identifier/type records. The final argument indicates whether the response is in the extended format or not.  The application should return true if the message was processed or false if it was not.
      </description>
      <arg name="clusterId"         type="EmberAfClusterId" description="The cluster identifier of this response." />
      <arg name="discoveryComplete" type="bool"          description="Indicates whether there are more attributes to be discovered.  true if there are no more attributes to be discovered." />
      <arg name="buffer"            type="uint8_t *"          description="Buffer containing the list of attribute identifier/type records." />
      <arg name="bufLen"            type="uint16_t"           description="The length in bytes of the list." />
      <arg name="extended"          type="bool"          description="Indicates whether the response is in the extended format or not." />
      <codeForStub>
        return false;
      </codeForStub>
    </function>
    <function id="DISCOVER_COMMANDS_RECEIVED_RESPONSE" name="Discover Commands Received Response" returnType="bool">
      <description>
        This function is called by the framework when Discover Commands Received Response is received.
      </description>
      <arg name="clusterId"         type="EmberAfClusterId" description="The cluster identifier of this response." />
      <arg name="manufacturerCode" type="uint16_t"            description="Manufacturer code"/>
      <arg name="discoveryComplete" type="bool"          description="Indicates whether there are more commands to be discovered." />
      <arg name="commandIds"        type="uint8_t *"          description="Buffer containing the list of command identifiers." />
      <arg name="commandIdCount"    type="uint16_t"           description="The length of bytes of the list, whish is the same as the number of identifiers." />
      <codeForStub>
        return false;
      </codeForStub>
    </function>
    <function id="DISCOVER_COMMANDS_GENERATED_RESPONSE" name="Discover Commands Generated Response" returnType="bool">
      <description>
        This function is called by the framework when Discover Commands Generated Response is received.
      </description>
      <arg name="clusterId"         type="EmberAfClusterId" description="The cluster identifier of this response." />
      <arg name="manufacturerCode" type="uint16_t"            description="Manufacturer code"/>
      <arg name="discoveryComplete" type="bool"          description="Indicates whether there are more commands to be discovered." />
      <arg name="commandIds"        type="uint8_t *"          description="Buffer containing the list of command identifiers." />
      <arg name="commandIdCount"    type="uint16_t"           description="The length of bytes of the list, whish is the same as the number of identifiers." />
      <codeForStub>
        return false;
      </codeForStub>
    </function>
    <function id="NET_WRITE" name="Allow Network Write Attribute" returnType="EmberAfAttributeWritePermission">
      <description>
        This function is called by the application framework before it writes an attribute in response to a write attribute request from an external device. The value passed into this callback is the value to which the attribute is to be set by the framework.
        Example:	In mirroring simple metering data on an Energy Services Interface (ESI) (formerly called Energy Service Portal (ESP) in SE 1.0).), a mirrored simple meter needs to write read-only attributes on its mirror. The-meter-mirror sample application, located in app/framework/sample-apps, uses this callback to allow the mirrored device to write simple metering attributes on the mirror regardless of the fact that most simple metering attributes are defined as read-only by the ZigBee specification.
        Note:	The ZCL specification does not (as of this writing) specify any permission-level security for writing writeable attributes. As far as the ZCL specification is concerned, if an attribute is writeable, any device that has a link key for the device should be able to write that attribute. Furthermore if an attribute is read only, it should not be written over the air. Thus, if you implement permissions for writing attributes as a feature, you MAY be operating outside the specification. This is unlikely to be a problem for writing read-only attributes, but it may be a problem for attributes that are writeable according to the specification but restricted by the application implementing this callback.
      </description>
      <arg name="endpoint" type="uint8_t" />
      <arg name="clusterId" type="EmberAfClusterId" />
      <arg name="attributeId" type="EmberAfAttributeId" />
      <arg name="mask" type="uint8_t" />
      <arg name="manufacturerCode" type="uint16_t" />
      <arg name="value" type="uint8_t*" />
      <arg name="type" type="uint8_t" />
      <codeForStub>
        return EMBER_ZCL_ATTRIBUTE_WRITE_PERMISSION_ALLOW_WRITE_NORMAL; // Default
      </codeForStub>
    </function>
    <function id="PRE_ATTR_CH" name="Pre Attribute Change" returnType="EmberAfStatus">
      <description>
        This function is called by the application framework before it changes an attribute value.  The value passed into this callback is the value to which the attribute is to be set by the framework.  The application should return ::EMBER_ZCL_STATUS_SUCCESS to permit the change or any other ::EmberAfStatus to reject it.
      </description>
      <arg name="endpoint" type="uint8_t" />
      <arg name="clusterId" type="EmberAfClusterId" />
      <arg name="attributeId" type="EmberAfAttributeId" />
      <arg name="mask" type="uint8_t" />
      <arg name="manufacturerCode" type="uint16_t" />
      <arg name="type" type="uint8_t" />
      <arg name="size" type="uint8_t" />
      <arg name="value" type="uint8_t*" />
      <codeForStub>
        return EMBER_ZCL_STATUS_SUCCESS;
      </codeForStub>
    </function>
    <function id="POST_ATTR_CH" name="Post Attribute Change" returnType="void">
      <description>
        This function is called by the application framework after it changes an attribute value. The value passed into this callback is the value to which the attribute was set by the framework.
      </description>
      <arg name="endpoint" type="uint8_t" />
      <arg name="clusterId" type="EmberAfClusterId" />
      <arg name="attributeId" type="EmberAfAttributeId" />
      <arg name="mask" type="uint8_t" />
      <arg name="manufacturerCode" type="uint16_t" />
      <arg name="type" type="uint8_t" />
      <arg name="size" type="uint8_t" />
      <arg name="value" type="uint8_t*" />
      <codeForStub>
      </codeForStub>
    </function>
    <function id="PRE_MSG" name="Pre Message Received" returnType="bool">
      <description>
        This callback is the first in the Application Framework's message processing chain. The Application Framework calls it when a message has been received over the air but has not yet been parsed by the ZCL command-handling code. If you wish to parse some messages that are completely outside the ZCL specification or are not handled by the Application Framework's command handling code, you should intercept them for parsing in this callback. 
        This callback returns a Boolean value indicating whether or not the message has been handled. If the callback returns a value of true, then the Application Framework assumes that the message has been handled and it does nothing else with it. If the callback returns a value of false, then the application framework continues to process the message as it would with any incoming message.
        Note: 	This callback receives a pointer to an incoming message struct. This struct allows the application framework to provide a unified interface between both Host devices, which receive their message through the ezspIncomingMessageHandler, and SoC devices, which receive their message through emberIncomingMessageHandler.
      </description>
      <arg name="incomingMessage" type="EmberAfIncomingMessage*" />
      <codeForStub>
        return false;
      </codeForStub>
    </function>
    <function id="PRE_CMD"  name="Pre Command Received" returnType="bool">
      <description>
        This callback is the second in the Application Framework's message processing chain. At this point in the processing of incoming over-the-air messages, the application has determined that the incoming message is a ZCL command. It parses enough of the message to populate an EmberAfClusterCommand struct. The Application Framework defines this struct value in a local scope to the command processing but also makes it available through a global pointer called emberAfCurrentCommand, in app/framework/util/util.c. When command processing is complete, this pointer is cleared.
      </description>
      <arg name="cmd" type="EmberAfClusterCommand*" />
      <codeForStub>
        return false;
      </codeForStub>
    </function>
    <function id="PRE_ZDO" name="Pre ZDO Message Received" returnType="bool">
      <description>
        This function passes the application an incoming ZDO message and gives the appictation the opportunity to handle it. By default, this callback returns false indicating that the incoming ZDO message has not been handled and should be handled by the Application Framework.
      </description>
      <arg name="emberNodeId" type="EmberNodeId" />
      <arg name="apsFrame" type="EmberApsFrame*" />
      <arg name="message" type="uint8_t*" />
      <arg name="length" type="uint16_t" />
      <codeForStub>
        return false;
      </codeForStub>
    </function>
    <function id="MSG_SENT" name="Message Sent" returnType="bool">
      <description>
        This function is called by the application framework from the message sent handler, when it is informed by the stack regarding the message sent status. All of the values passed to the emberMessageSentHandler are passed on to this callback. This provides an opportunity for the application to verify that its message has been sent successfully and take the appropriate action. This callback should return a bool value of true or false. A value of true indicates that the message sent notification has been handled and should not be handled by the application framework.
      </description>
      <arg name="type" type="EmberOutgoingMessageType" />
      <arg name="indexOrDestination" type="uint16_t" />
      <arg name="apsFrame" type="EmberApsFrame*" />
      <arg name="msgLen" type="uint16_t" />
      <arg name="message" type="uint8_t*" />
      <arg name="status" type="EmberStatus" />
      <codeForStub>
        return false;
      </codeForStub>
    </function>
    <function id="STACK_STATUS" name="Stack Status" returnType="bool">
      <description>
        This function is called by the application framework from the stack status handler.  This callbacks provides applications an opportunity to be notified of changes to the stack status and take appropriate action.  The return code from this callback is ignored by the framework.  The framework will always process the stack status after the callback returns.
      </description>
      <arg name="status" type="EmberStatus" />
      <codeForStub>
        return false;
      </codeForStub>
    </function>
    <function id="NCP_INIT" name="Ncp Init" returnType="void">
      <description>
        This function is called when the network coprocessor is being initialized, either at startup or upon reset.  It provides applications on opportunity to perform additional configuration of the NCP.  The function is always called twice when the NCP is initialized.  In the first invocation, memoryAllocation will be true and the application should only issue EZSP commands that affect memory allocation on the NCP.  For example, tables on the NCP can be resized in the first call.  In the second invocation, memoryAllocation will be false and the application should only issue EZSP commands that do not affect memory allocation.  For example, tables on the NCP can be populated in the second call.  This callback is not called on SoCs.
      </description>
      <arg name="memoryAllocation" type="bool" />
    </function>
    <function id="MAIN_INIT" name="Main Init" returnType="void">
      <description>
        This function is called from the application's main function. It gives the application a chance to do any initialization required at system startup. Any code that you would normally put into the top of the application's main() routine should be put into this function. This is called before the clusters, plugins, and the network are initialized so some functionality is not yet available.
        Note: No callback in the Application Framework is associated with resource cleanup. If you are implementing your application on a Unix host where resource cleanup is a consideration, we expect that you will use the standard Posix system calls, including the use of atexit() and handlers for signals such as SIGTERM, SIGINT, SIGCHLD, SIGPIPE and so on. If you use the signal() function to register your signal handler, please mind the returned value which may be an Application Framework function. If the return value is non-null, please make sure that you call the returned function from your handler to avoid negating the resource cleanup of the Application Framework itself.
      </description>
      <codeForStub>
      </codeForStub>
    </function>
    <function id="CLUSTER_INIT" name="Cluster Init" returnType="void">
      <description>
        This function is called when a specific cluster is initialized. It gives the application an opportunity to take care of cluster initialization procedures. It is called exactly once for each endpoint where cluster is present.
      </description>
      <arg name="endpoint" type="uint8_t" />
      <arg name="clusterId" type="EmberAfClusterId" />
      <codeForStub>
      </codeForStub>
    </function>
    <function id="MAIN_TICK" name="Main Tick" returnType="void">
      <description>
        Whenever main application tick is called, this callback will be called at the end of the main tick execution.
      </description>
      <codeForStub>
      </codeForStub>
    </function>
    <function id="ATT_WRITE_ACCESS"
              name="Attribute Write Access"
              returnType="bool">
      <description>
        This function is called whenever the Application Framework needs to check access permission for an attribute write.
      </description>
      <arg name="endpoint"         type="uint8_t" />
      <arg name="clusterId"        type="EmberAfClusterId" />
      <arg name="manufacturerCode" type="uint16_t" />
      <arg name="attributeId"      type="uint16_t" />
      <codeForStub>
        return true;
      </codeForStub>
    </function>

    <function id="ATT_READ_ACCESS" 
              name="Attribute Read Access" 
              returnType="bool">
      <description>
        This function is called whenever the Application Framework needs to check access permission for an attribute read.
      </description>
      <arg name="endpoint"         type="uint8_t" />
      <arg name="clusterId"        type="EmberAfClusterId" />
      <arg name="manufacturerCode" type="uint16_t" />
      <arg name="attributeId"      type="uint16_t" />
      <codeForStub>
        return true;
      </codeForStub>
    </function>

    <function id="EXT_ATT_WRITE" 
              name="External Attribute Write" 
              returnType="EmberAfStatus"
              category="EXTERNAL_ATTRIBUTE">
      <description>
        This function is called whenever the Application Framework needs to write an attribute which is not stored within the data structures of the Application Framework itself. One of the new features in Version 2 is the ability to store attributes outside the Framework. This is particularly useful for attributes that do not need to be stored because they can be read off the hardware when they are needed, or are stored in some central location used by many modules within the system. In this case, you can indicate that the attribute is stored externally. When the framework needs to write an external attribute, it makes a call to this callback.
        This callback is very useful for host micros which need to store attributes in persistent memory. Because each host micro (used with an Ember NCP) has its own type of persistent memory storage, the Application Framework does not include the ability to mark attributes as stored in flash the way that it does for Ember SoCs like the EM35x. On a host micro, any attributes that need to be stored in persistent memory should be marked as external and accessed through the external read and write callbacks. Any host code associated with the persistent storage should be implemented within this callback.
        All of the important information about the attribute itself is passed as a pointer to an EmberAfAttributeMetadata struct, which is stored within the application and used to manage the attribute. A complete description of the EmberAfAttributeMetadata struct is provided in app/framework/include/af-types.h.
        This function assumes that the application is able to write the attribute and return immediately. Any attributes that require a state machine for reading and writing are not candidates for externalization at the present time. The Application Framework does not currently include a state machine for reading or writing attributes that must take place across a series of application ticks. Attributes that cannot be written immediately should be stored within the Application Framework and updated occasionally by the application code from within the emberAfMainTickCallback.
        If the application was successfully able to write the attribute, it returns a value of EMBER_ZCL_STATUS_SUCCESS. Any other return value indicates the application was not able to write the attribute.
      </description>
      <arg name="endpoint" type="uint8_t" />
      <arg name="clusterId" type="EmberAfClusterId" />
      <arg name="attributeMetadata" type="EmberAfAttributeMetadata *"/>
      <arg name="manufacturerCode" type="uint16_t" />
      <arg name="buffer" type="uint8_t *"/>
      <codeForStub>
        return EMBER_ZCL_STATUS_FAILURE;
      </codeForStub>
    </function>
    <function id="EXT_ATT_READ"
              name="External Attribute Read" 
              returnType="EmberAfStatus"
              category="EXTERNAL_ATTRIBUTE">
      <description>
        Like emberAfExternalAttributeWriteCallback above, this function is called when the framework needs to read an attribute that is not stored within the Application Framework's data structures.
        All of the important information about the attribute itself is passed as a pointer to an EmberAfAttributeMetadata struct, which is stored within the application and used to manage the attribute. A complete description of the EmberAfAttributeMetadata struct is provided in app/framework/include/af-types.h
        This function assumes that the application is able to read the attribute, write it into the passed buffer, and return immediately. Any attributes that require a state machine for reading and writing are not really candidates for externalization at the present time. The Application Framework does not currently include a state machine for reading or writing attributes that must take place across a series of application ticks. Attributes that cannot be read in a timely manner should be stored within the Application Framework and updated occasionally by the application code from within the emberAfMainTickCallback.
        If the application was successfully able to read the attribute and write it into the passed buffer, it should return a value of EMBER_ZCL_STATUS_SUCCESS. Any other return value indicates the application was not able to read the attribute.
      </description>
      <arg name="endpoint" type="uint8_t" />
      <arg name="clusterId" type="EmberAfClusterId" />
      <arg name="attributeMetadata" type="EmberAfAttributeMetadata *"/>
      <arg name="manufacturerCode" type="uint16_t" />
      <arg name="buffer" type="uint8_t *"/>
      <codeForStub>
        return EMBER_ZCL_STATUS_FAILURE;
      </codeForStub>
    </function>
    <function id="TRUST_CENTER_JOIN"
              name="Trust Center Join" 
              returnType="void">
      <description>
        This callback is called from within the application framework's implementation of emberTrustCenterJoinHandler or ezspTrustCenterJoinHandler. This callback provides the same arguments passed to the TrustCenterJoinHandler. For more information about the TrustCenterJoinHandler please see documentation included in stack/include/trust-center.h.
      </description>
      <arg name="newNodeId" type="EmberNodeId" />
      <arg name="newNodeEui64" type="EmberEUI64" />
      <arg name="parentOfNewNode" type="EmberNodeId"/>
      <arg name="status" type="EmberDeviceUpdate"/>
      <arg name="decision" type="EmberJoinDecision"/>
      <codeForStub>
      </codeForStub>
    </function>
    <function id="GET_CURRENT_TIME"
              name="Get Current Time" 
              returnType="uint32_t">
      <description>
        This callback is called when device attempts to get current time from the hardware. If this device has means to retrieve exact time, then this method should implement it. If the callback can't provide the exact time it should return 0 to indicate failure. Default action is to return 0, which indicates that device does not have access to real time.
      </description>
      <codeForStub>
        return 0;
      </codeForStub>
    </function>
    <function id="SET_TIME"
              name="Set Time" 
              returnType="void">
      <description>
        This callback should be implemented, if the device has access to real time clock, and has an ability to update that clock. The application framework expects to be passed the utcTime which is the number of seconds since the year 2000. Default implementation does nothing. Note: This function used to take time in year, month, day, hour, min, sec. We have changed this to utcTime in order to conserve code space.
      </description>
        <arg name="utcTime" type="uint32_t" />
      <codeForStub>
      </codeForStub>
    </function>
    <function id="INITIATE_KEY_ESTABLISHMENT" name="Initiate Key Establishment" returnType="EmberStatus">
      <description>
        This function is called by the framework to initiate key establishment with a remote device.  The application should return EMBER_SUCCESS if key establishment was initiated successfully.  The application should call ::emberAfKeyEstablishmentCallback as events occur.
      </description>
      <arg name="nodeId"   type="EmberNodeId" description="The node id of the remote device." />
      <arg name="endpoint" type="uint8_t"       description="The endpoint on the remote device." />
      <codeForStub>
        return EMBER_LIBRARY_NOT_PRESENT;
      </codeForStub>
    </function>
    <function id="INITIATE_INTER_PAN_KEY_ESTABLISHMENT" name="Initiate Inter Pan Key Establishment" returnType="EmberStatus">
      <description>
        This function is called by the framework to initiate key establishment with a remote device on a different PAN.  The application should return EMBER_SUCCESS if key establishment was initiated successfully.  The application should call ::emberAfInterPanKeyEstablishmentCallback as events occur.
      </description>
      <arg name="panId" type="EmberPanId"       description="The PAN id of the remote device." />
      <arg name="eui64" type="const EmberEUI64" description="The EUI64 of the remote device." />
      <codeForStub>
        return EMBER_LIBRARY_NOT_PRESENT;
      </codeForStub>
    </function>
    <function id="KEY_ESTABLISHMENT" name="Key Establishment" returnType="bool">
      <description>
        A callback by the key-establishment code to indicate an event has occurred.  For error codes this is purely a notification.  For non-error status codes (besides LINK_KEY_ESTABLISHED), it is the application's chance to allow or disallow the operation.  If the application returns true then the key establishment is allowed to proceed.  If it returns false, then key establishment is aborted.  LINK_KEY_ESTABLISHED is a notification of success.
      </description>
      <arg name="status"         type="EmberAfKeyEstablishmentNotifyMessage" />
      <arg name="amInitiator"    type="bool"                              />
      <arg name="partnerShortId" type="EmberNodeId"                          />
      <arg name="delayInSeconds" type="uint8_t"                                />
      <codeForStub>
        return true;
      </codeForStub>
    </function>
    <function id="INTER_PAN_KEY_ESTABLISHMENT" name="Inter Pan Key Establishment" returnType="bool">
      <description>
        A callback by the key-establishment code to indicate an event has occurred.  For error codes this is purely a notification.  For non-error status codes (besides LINK_KEY_ESTABLISHED), it is the application's chance to allow or disallow the operation.  If the application returns true then the key establishment is allowed to proceed.  If it returns false, then key establishment is aborted.  LINK_KEY_ESTABLISHED is a notification of success.
      </description>
      <arg name="status"         type="EmberAfKeyEstablishmentNotifyMessage" />
      <arg name="amInitiator"    type="bool"                              />
      <arg name="panId"          type="EmberPanId"                           />
      <arg name="eui64"          type="const EmberEUI64"                     />
      <arg name="delayInSeconds" type="uint8_t"                                />
      <codeForStub>
        return true;
      </codeForStub>
    </function>
    <function id="PERFORMING_KEY_ESTABLISHMENT" name="Performing Key Establishment" returnType="bool">
      <description>
        This function is called by the framework to determine if the device is performing key establishment.  The application should return true if key establishment is in progress.
      </description>
      <codeForStub>
        return false;
      </codeForStub>
    </function>
    <function id="INITIATE_PARTNER_LINK_KEY_EXCHANGE" name="Initiate Partner Link Key Exchange" returnType="EmberStatus">
      <description>
        This function is called by the framework to initiate a partner link key exchange with a remote device.  The application should return EMBER_SUCCESS if the partner link key exchange was initiated successfully.  When the partner link key exchange completes, the application should call the given callback.
      </description>
      <arg name="target"   type="EmberNodeId"                             description="The node id of the remote device." />
      <arg name="endpoint" type="uint8_t"                                   description="The key establishment endpoint of the remote device." />
      <arg name="callback" type="EmberAfPartnerLinkKeyExchangeCallback *" description="The callback that should be called when the partner link key exchange completse." />
      <codeForStub>
        return EMBER_LIBRARY_NOT_PRESENT;
      </codeForStub>
    </function>
    <function id="PARTNER_LINK_KEY_EXCHANGE_REQUEST" name="Partner Link Key Exchange Request" returnType="EmberStatus">
      <description>
        This function is called by the framework on SOC platforms when a remote node requests a partner link key exchange.  The application should return EMBER_SUCCESS to accept the request or any other status to reject it.  On network coprocessor platforms, this function will not be called because the NCP handles partner link key exchange requests based on the binding policy.
      </description>
      <arg name="partner" type="EmberEUI64" description="The EUI of the remote node." />
      <codeForStub>
        return EMBER_LIBRARY_NOT_PRESENT;
      </codeForStub>
    </function>
    <function id="PARTNER_LINK_KEY_EXCHANGE_RESPONSE" name="Partner Link Key Exchange Response" returnType="void">
      <description>
        This function is called by the framework when a remote node requests a partner link key exchange.  The application should return true to accept the request or false to reject it.  On network coprocessor platforms, this function will not be called because the NCP handles partner link key exchange requests based on the binding policy.
      </description>
      <arg name="sender" type="EmberNodeId"    description="The EUI of the remote node." />
      <arg name="status" type="EmberZdoStatus" description="The ZDO response status." />
      <codeForStub />
    </function>
    <function id="REGISTRATION_START" name="Registration Start" returnType="EmberStatus">
      <description>
        This callback is called when the device joins a network and the registration process should begin.  The application should return EMBER_SUCCESS if the registration process started successfully.  When registration is complete, the application should call emberAfRegistrationCallback with an indication of success or failure.
      </description>
      <codeForStub>
        return EMBER_LIBRARY_NOT_PRESENT;
      </codeForStub>
    </function>
    <function id="REGISTRATION_ABORT" name="Registration Abort" returnType="void">
      <description>
        This callback is called when the device should abort the registration process.  
      </description>
    </function>
    <function id="REGISTRATION" name="Registration" returnType="void">
      <description>
        This callback is called when the device joins a network and the process of registration is complete. This callback provides a success value of true if the registration process was successful and a value of false if registration failed.
      </description>
      <arg name="success" type="bool" description="true if registration succeeded, false otherwise."/>
    </function>
    <function id="TRUST_CENTER_KEEPALIVE_UPDATE" name="Trust Center Keepalive Update" returnType="void">
      <description>
        This callback is called when the device finishes registration (successfully or otherwise) and the trust center keepalive process must be updated.  If the keepalive process has not been started, then it is started.  Otherwise if the keepalive is in the process of searching for the TC, it will process the result of that Trust Center search operation.
      </description>
      <arg name="registrationComplete" type="bool" />
    </function>
    <function id="TRUST_CENTER_KEEPALIVE_ABORT" name="Trust Center Keepalive Abort" returnType="void">
      <description>
        This callback is called when the device should abort the trust center keepalive process.  
      </description>
    </function>
    <function id="OTA_SERVER_INCOMING_MESSAGE_RAW" name="Ota Server Incoming Message Raw" returnType="bool">
    <description>
      This callback is for processing incoming messages for the Over-the-air bootload cluster server.  ZCL will not process the message and instead hand the raw over the air data to the callback for its own processing.
    </description>
    <arg name="message" type="EmberAfClusterCommand *" description="A pointer to the structure containing the message buffer and other information about it."/>
      <codeForStub>
        return false;
      </codeForStub>
    </function>
    <function id="OTA_SERVER_SEND_IMAGE_NOTIFY" name="Ota Server Send Image Notify" returnType="bool">
      <description>
        This callback is an indication to the OTA server that it should send out notification about an OTA file that is available for download.
      </description>
      <arg name="dest" type="EmberNodeId" description="The destination of the image notify message.  May be a broadcast address."/>
      <arg name="endpoint" type="uint8_t" description="The destination endpoint of the image notify message.  May be a broadcast endpoint."/>
      <arg name="payloadType" type="uint8_t" description="The type of data the image notify message will contain.  0 = no data.  1 = Manufacturer ID.  2 = Manufacturer ID and the image type ID.  3 = Manufacturer ID, image type ID, and firmware version."/>
      <arg name="queryJitter" type="uint8_t" description="The percentage of nodes that should respond to this message, from 1-100.  On receipt of this message, each recipient will randomly choose a percentage and only query the server if their percentage is below this value."/>
      <arg name="id" type="const EmberAfOtaImageId*" description="The image information that will be put in the message.  The data within this struct that will be appended to the message is determined by the previous 'payloadType' argument."/>
      <codeForStub>
        return false;
      </codeForStub>
    </function>
<!-- NOTE:  This should be turned into a plugin callback instead of a generic callback.  But for now it is here (RBA).-->
    <function id="OTA_STORAGE_DRIVER_INIT" name="Ota Storage Driver Init" returnType="bool">
      <description>
        The initialization code for the OTA storage driver.
      </description>
      <codeForStub>
// The storage driver and the rest of the OTA bootload code will not function correctly unless it is implemnted.
  // Please implement me.
  assert(false);
  return false;
      </codeForStub>
    </function>
<!-- NOTE:  This should be turned into a plugin callback instead of a generic callback.  But for now it is here (RBA).-->
    <function id="OTA_STORAGE_DRIVER_READ" name="Ota Storage Driver Read" returnType="bool">
      <description>
        This callback defines the low-level means by which a device reads from the OTA storage device.
      </description>
      <arg name="offset" type="uint32_t" description="The address offset from the start of the storage device where data is to be read."/>
      <arg name="length" type="uint32_t" description="The length of the data to be read from the storage device."/>
      <arg name="returnData" type="uint8_t*" description="A pointer where the data read from the device should be written to."/>
      <codeForStub>
// The storage driver and the rest of the OTA bootload code will not function correctly unless it is implemnted.
  // Please implement me.
  assert(false);
  return false;
      </codeForStub>
    </function>
<!-- NOTE:  This should be turned into a plugin callback instead of a generic callback.  But for now it is here (RBA).-->
    <function id="OTA_STORAGE_DRIVER_WRITE" name="Ota Storage Driver Write" returnType="bool">
      <description>
        This callback defines the low-level means by which a device reads from the OTA storage device.
      </description>
      <arg name="dataToWrite" type="const uint8_t*" description="A pointer to the data that will be written to the storage device."/>
      <arg name="offset" type="uint32_t" description="The address offset from the start of the storage device where data will be written."/>
      <arg name="length" type="uint32_t" description="The length of the data to be written to the storage device."/>
      <codeForStub>
// The storage driver and the rest of the OTA bootload code will not function correctly unless it is implemnted.
  // Please implement me.
  assert(false);
  return false;
      </codeForStub>
    </function>
<!-- NOTE:  This should be turned into a plugin callback instead of a generic callback.  But for now it is here (RBA).-->
  <function id="OTA_STORAGE_DRIVER_DOWNLOAD_FINISH" name="Ota Storage Driver Download Finish" returnType="void">
    <description>
      This callback defines the low-level means by which a device records the final offset value of the download image.
    </description>
    <arg name="offset" type="uint32_t" description="The value of the final offset of the image download."/>
    <codeForStub>
// The storage driver and the rest of the OTA bootload code will not function correctly unless it is implemnted.
  // Please implement me.
  assert(false);
    </codeForStub>
  </function>
<!-- NOTE:  This should be turned into a plugin callback instead of a generic callback.  But for now it is here (RBA).-->
  <function id="OTA_STORAGE_DRIVER_RETRIEVE_LAST_STORED_OFFSET" name="Ota Storage Driver Retrieve Last Stored Offset" returnType="uint32_t">
    <description>
      This callback defines the low-level means by which a device retrieves the last persistently recorded download offset.  This may be different than last actual download offset.
    </description>
    <codeForStub>
// The storage driver and the rest of the OTA bootload code will not function correctly unless it is implemnted.
  // Please implement me.
  assert(false);
  return 0;
    </codeForStub>
  </function>
<!-- NOTE:  This should be turned into a plugin callback instead of a generic callback.  But for now it is here (RBA).-->
  <function id="OTA_STORAGE_DRIVER_INVALIDATE_IMAGE" name="Ota Storage Driver Invalidate Image" returnType="EmberAfOtaStorageStatus">
    <description>
      This callback invalidates the image stored on disk so that it will not be bootloaded, and it will not be a valid image that is in the middle of downloading.
    </description>
    <codeForStub>
// The storage driver and the rest of the OTA bootload code will not function correctly unless it is implemnted.
  // Please implement me.
  assert(false);
  return EMBER_AF_OTA_STORAGE_ERROR;
    </codeForStub>
  </function>
<!-- NOTE:  This should be turned into a plugin callback instead of a generic callback.  But for now it is here (RBA).-->
  <function id="OTA_STORAGE_DRIVER_PREPARE_TO_RESUME_DOWNLOAD" name="Ota Storage Driver Prepare To Resume Download" returnType="EmberAfOtaStorageStatus">
    <description>
      This callback allows the underlying storage driver to prepare to resume the OTA file download.  For example, the driver may exceute a page erase to insure the next page is ready to be written to.
    </description>
    <codeForStub> 
  assert(false);
  return EMBER_AF_OTA_STORAGE_ERROR;
    </codeForStub>
  </function>
<!-- NOTE:  This should be turned into a plugin callback instead of a generic callback.  But for now it is here (RBA).-->
    <function id="OTA_BOOTLOAD" name="Ota Bootload" returnType="uint8_t">
      <description>
        The platform specific routine to bootload the device from a ZigBee over-the-air upgrade file.
      </description>
      <arg name="id" type="const EmberAfOtaImageId*" description="A pointer to the structure that contains the information about what OTA image to bootload."/>
      <arg name="ncpUpgradeTagId" type="uint16_t" description="The tag ID of the upgrade data that will be used to bootload the device."/>
      <codeForStub>
// Please implement me
  emberAfCorePrintln("Not supported.");
  return 1;
      </codeForStub>
    </function>
<!-- NOTE:  This should be turned into a plugin callback instead of a generic callback.  But for now it is here (RBA).-->
    <function id="OTA_STORAGE_INIT" name="Ota Storage Init" returnType="EmberAfOtaStorageStatus">
      <description>
        This callback initializes the ZigBee Over-the-air storage module.
      </description>
      <codeForStub>
  return EMBER_AF_OTA_STORAGE_SUCCESS;
      </codeForStub>
    </function>
<!-- NOTE:  This should be turned into a plugin callback instead of a generic callback.  But for now it is here (RBA).-->
    <function id="OTA_STORAGE_CLOSE" name="Ota Storage Close" returnType="void">
      <description>
        This callback shuts down the ZigBee Over-the-air storage module.
      </description>
      <codeForStub>
// Please implement me.
  assert(false);
      </codeForStub>
    </function>
<!-- NOTE:  This should be turned into a plugin callback instead of a generic callback.  But for now it is here (RBA).-->
    <function id="OTA_STORAGE_GET_COUNT" name="Ota Storage Get Count" returnType="uint8_t">
      <description>
        This callback returns the total number of ZigBee Over-the-air upgrade images stored in the storage module.
      </description>
      <codeForStub>
return 0;
      </codeForStub>
    </function>
<!-- NOTE:  This should be turned into a plugin callback instead of a generic callback.  But for now it is here (RBA).-->
    <function id="OTA_STORAGE_SEARCH" name="Ota Storage Search" returnType="EmberAfOtaImageId">
      <description>
      This callback searches through the list of all images for one that matches the passed parameters.  On success an image identifier is returned with a matching image.  On failure emberAfInvalidImageId is returned.
      </description>
      <arg name="manufacturerId" type="uint16_t" description="The ZigBee assigned identifier of the manufacturer contained in the OTA image being searched for."/>
      <arg name="imageTypeId"    type="uint16_t" description="The image type identifier contained in the OTA image being searched for."/>
      <arg name="hardwareVersion" type="const uint16_t*" description="This is a pointer to the hardware version that will be used in the search.  If the pointer is NULL, hardware version will not be considered when searching for matching images.  If it points to a value, the search will only consider images where that value falls between the minimum and maxmimum hardware version specified in the OTA file.  If no hardware version is present in an OTA file but the other parameters match, the file will be considered a match"/>
      <codeForStub>
// If no image is found that matches the search criteria, this function should return the invalid image id.
  return emberAfInvalidImageId;
      </codeForStub>
    </function>
<!-- NOTE:  This should be turned into a plugin callback instead of a generic callback.  But for now it is here (RBA).-->
    <function id="OTA_STORAGE_GET_TOTAL_IMAGE_SIZE" name="Ota Storage Get Total Image Size" returnType="uint32_t">
      <description>
        This function returns the total size of the ZigBee Over-the-air file with the passed parameters.  If no file is found with those parameters, 0 is returned.
      </description>
      <arg name="id" type="const EmberAfOtaImageId*" description="A pointer to the image identifier for the OTA file to retrieve information for."/>
      <codeForStub>
// On failure this should return an image size of zero.
  return 0;
      </codeForStub>
    </function>
<!-- NOTE:  This should be turned into a plugin callback instead of a generic callback.  But for now it is here (RBA).-->
    <function id="OTA_STORAGE_ITERATOR_FIRST" name="Ota Storage Iterator First" returnType="EmberAfOtaImageId">
      <description>
        This callback lets you walk through the list of all OTA files by jumping to the first file in the list maintained by the storage module.  If there is no file then emberAfOtaInvalidImageId is returned.
      </description>
      <codeForStub>
// It is expected that the storage module maintain its own internal iterator that the 'first' and 'next' functions will manipulate.

  // If there are no images at all, this function should return the invalid image id.
  return emberAfInvalidImageId;
      </codeForStub>
    </function>
<!-- NOTE:  This should be turned into a plugin callback instead of a generic callback.  But for now it is here (RBA).-->
    <function id="OTA_STORAGE_ITERATOR_NEXT" name="Ota Storage Iterator Next" returnType="EmberAfOtaImageId">
      <description>
        This callback lets you walk through the list of all OTA files by jumping to the next file in the list maintained by the storage module.  If there is no next file then emberAfOtaInvalidImageId is returned.
      </description>
      <codeForStub>
// It is expected that the storage module maintain its own internal iterator that the 'first' and 'next' functions will manipulate.

  // If there are no more images, this function should return the invalid image id.
  return emberAfInvalidImageId;
      </codeForStub>
    </function>
<!-- NOTE:  This should be turned into a plugin callback instead of a generic callback.  But for now it is here (RBA).-->
    <function id="OTA_STORAGE_GET_FULL_HEADER" name="Ota Storage Get Full Header" returnType="EmberAfOtaStorageStatus">
      <description>
        This callback populates the EmberAfOtaHeader structure pointed to by the returnData with data about the OTA file stored in the storage module.
      </description>
      <arg name="id" type="const EmberAfOtaImageId*" description="This is a pointer to the image id for the OTA file to retrieve information about."/>
      <arg name="returnData" type="EmberAfOtaHeader*" description="This is a pointer to the location of the structure that will be populated with data."/>
      <codeForStub>
// If the requested image cannot be found, then an error shouldb e returned.
  return EMBER_AF_OTA_STORAGE_ERROR;
      </codeForStub>
    </function>
<!-- NOTE:  This should be turned into a plugin callback instead of a generic callback.  But for now it is here (RBA).-->
    <function id="OTA_STORAGE_READ_IMAGE_DATA" name="Ota Storage Read Image Data" returnType="EmberAfOtaStorageStatus">
      <description>
        This callback reads data from the specified OTA file and returns that data to the caller.
      </description>
      <arg name="id" type="const EmberAfOtaImageId*" description="This is a pointer to the image id for the OTA file to retrieve data from."/>
      <arg name="offset" type="uint32_t" description="This is the offset relative to the start of the image where the data should be read from."/>
      <arg name="length" type="uint32_t" description="This is the length of data that will be read."/>
      <arg name="returnData" type="uint8_t*" description="This is a pointer to where the data read out of the file will be written to"/>
      <arg name="returnedLength" type="uint32_t*" description="This is a pointer to a variable where the actual length of data read will be written to.  A short read may occur if the end of file was reached."/>
      <codeForStub>
// If the requested image cannot be found, then an error should be returned.
  return EMBER_AF_OTA_STORAGE_ERROR;
      </codeForStub>
    </function>
<!-- NOTE:  This should be turned into a plugin callback instead of a generic callback.  But for now it is here (RBA).-->
    <function id="OTA_STORAGE_CLEAR_TEMP_DATA" name="Ota Storage Clear Temp Data" returnType="EmberAfOtaStorageStatus">
      <description>
        This function clears any existing temp data that was downloaed.  It is used immediately prior to downloading a raw image over the air.
      </description>
      <codeForStub>
// If the image data cannot be stored, an error should be returned.
  return EMBER_AF_OTA_STORAGE_ERROR;
      </codeForStub>
    </function>
<!-- NOTE:  This should be turned into a plugin callback instead of a generic callback.  But for now it is here (RBA).-->
    <function id="OTA_STORAGE_WRITE_TEMP_DATA" name="Ota Storage Write Temp Data" returnType="EmberAfOtaStorageStatus">
      <description>
        This function writes to the temporary data in the storage device at the specified offset.  It is used when downloading a raw image over the air.
      </description>
      <arg name="offset" type="uint32_t" description="The location within the download image file where to write the data."/>
      <arg name="length" type="uint32_t" description="The length of data to write."/>
      <arg name="data" type="const uint8_t*" description="A pointer to the temporary data that will be written to the storage device."/>
      <codeForStub>
// If the image data cannot be stored, an error should be returned.
  return EMBER_AF_OTA_STORAGE_ERROR;
      </codeForStub>
    </function>
<!-- NOTE:  This should be turned into a plugin callback instead of a generic callback.  But for now it is here (RBA).-->
    <function id="OTA_STORAGE_CHECK_TEMP_DATA" name="Ota Storage Check Temp Data" returnType="EmberAfOtaStorageStatus">
      <description>
        This callback will validate temporary data in the storage device to determine whether it is a complete file, a partially downloaded file, or there is no file present.  When a complete or partial file is found it will return EMBER_AF_OTA_STORAGE_SUCCESS or EMBER_AF_OTA_STORAGE_PARTIAL_FILE_FOUND, respectively.  In that case, the currentOffset, totalImageSize, and newFileInfo will be populated with data.  When EMBER_AF_OTA_STORAGE_ERROR is returned, no temporary data is present.
      </description>
      <arg name="currentOffset" type="uint32_t*" description="A pointer to a value that will be written with the offset within the total file size that has been successfully stored in the storage device.  This will indicate how much data has been currently dowloaded."/>
      <arg name="totalImageSize" type="uint32_t*" description="A pointer to a value that will be written with the total image size of the OTA file when a download has completed.  This does not indicate how much data has actually been downloaded currently."/>
      <arg name="newFileInfo" type="EmberAfOtaImageId*" description="This is the image id of the temporary file data stored in the storage device."/>
      <codeForStub>
// If the image data cannot be successfully verified, an error should be returned.
  return EMBER_AF_OTA_STORAGE_ERROR;
      </codeForStub>
    </function>
<!-- NOTE:  This should be turned into a plugin callback instead of a generic callback.  But for now it is here (RBA).-->
    <function id="OTA_STORAGE_FINISH_DOWNLOAD" name="Ota Storage Finish Download" returnType="EmberAfOtaStorageStatus">
      <description>
        This function indicates to the storage module that the download has finished.
      </description>
      <arg name="offset" type="uint32_t" description="The final offset of the downloaded file (i.e. the total size)"/>
      <codeForStub>
  return EMBER_AF_OTA_STORAGE_SUCCESS;
      </codeForStub>      
    </function>
    <function id="OTA_CLIENT_INCOMING_MESSAGE_RAW" name="Ota Client Incoming Message Raw" returnType="bool">
      <description>
        This callback is for processing incoming messages for the Over-the-air bootload cluster client.  ZCL will not process the message and instead hand the raw over the air data to the callback for its own processing.
      </description>
      <arg name="message" type="EmberAfClusterCommand *" description="A pointer to the structure containing the message buffer and other information about it."/>
      <codeForStub>
        return false;
      </codeForStub>
    </function>
    <function id="OTA_CLIENT_START" name="Ota Client Start" returnType="void">
      <description>
        This callback should be called when the profile specific registration has completed successfully.  It will start the client's state machine that will find the OTA server, query it for the next image, download the image, wait for the bootload message, and kick off the bootload.
      </description>
    </function>
<!-- NOTE:  This should be turned into a plugin callback instead of a generic callback.  But for now it is here (RBA).-->
    <function id="OTA_CLIENT_VERSION_INFO" name="Ota Client Version Info" returnType="void">
      <description>
        This function is called by the OTA client when a new query will occur to the server asking what the next version of firmware is.  The client can inform the cluster software as to what information to use in the query (and subsequent download). 
      </description>
      <arg name="currentImageInfo" type="EmberAfOtaImageId*" description="This is the information to use in the next query by the client cluster code.  It contains the manufacturer ID, image type ID, and the firmware version to be specified in the query message sent to the server."/>
      <arg name="hardwareVersion" type="uint16_t*" description="This is a pointer to the hardware version to use in the query.  If no hardware version should be used, then EMBER_AF_INVALID_HARDWARE_VERSION should be used."/>
      <codeForStub>
// Customer will fill in the image info with their manufacturer ID,
  // image type ID, and current software version number.
  // The deviceSpecificFileEui64 can be ignored.

  // It may be necessary to dynamically determine this by talking to
  // another device, as is the case with a host talking to an NCP device.

  // However, this routine will be called repeatedly so it may be wise
  // to cache the data!

/* This is commented out since the #defines below are not defined.

  if (currentImageInfo != NULL) {
    MEMSET(currentImageInfo, 0, sizeof(EmberAfOtaImageId));
    currentImageInfo->manufacturerId  = EMBER_AF_MANUFACTURER_CODE;
    currentImageInfo->imageTypeId     = EMBER_AF_IMAGE_TYPE_ID;
    currentImageInfo->firmwareVersion = EMBER_AF_CUSTOM_FIRMWARE_VERSION;
  }

  if (hardwareVersion != NULL) {
    *hardwareVersion = EMBER_AF_INVALID_HARDWARE_VERSION;
  }

  assert(false);
*/
      </codeForStub>
    </function>
<!-- NOTE:  This should be turned into a plugin callback instead of a generic callback.  But for now it is here (RBA).-->
    <function id="OTA_CLIENT_CUSTOM_VERIFY_CALLBACK" name="Ota Client Custom Verify" returnType="EmberAfImageVerifyStatus">
      <description>
        This callback is executed by the OTA client after the signature verification has successfully completed.  It allows the device to do its own custom verification of the image (such as verifying that the EBL is intact).
      </description>
      <arg name="newVerification" type="bool" description="This indicates if a new verification should be started."/>
      <arg name="id" type="const EmberAfOtaImageId*" description="This is ID of the image to be verified."/>
      <codeForStub>
// Manufacturing specific checks can be made to the image in this function to
  // determine if it is valid.  This function is called AFTER cryptographic 
  // checks have passed.  If the cryptographic checks failed, this function will
  // never be called.
  
  // The function shall return one of the following based on its own 
  // verification process.
  // 1) EMBER_AF_IMAGE_GOOD - the image has passed all checks
  // 2) EMBER_AF_IMAGE_BAD  - the image is not valid 
  // 3) EMBER_AF_IMAGE_VERIFY_IN_PROGRESS - the image is valid so far, but more
  //      checks are needed.  This callback shall be re-executed later to 
  //      continue verification.  This allows other code in the framework to run.
  return EMBER_AF_IMAGE_GOOD;
      </codeForStub>
    </function>
<!-- NOTE:  This should be turned into a plugin callback instead of a generic callback.  But for now it is here (RBA).-->
    <function id="OTA_CLIENT_DOWNLOAD_COMPLETE" name="Ota Client Download Complete" returnType="bool">
      <description>
        This callback indicates that the OTA client has completed the download of a file.  If the file has been completely downloaded and cryptographic checks have been turned on, then those will be performed prior to this callback and that outcome included in the 'success' result.  On failure, this callback is merely informative, and the return type is ignored.  On succesful download, this callback allows the client to perform any additional verification of the downloaded image and return that result to the OTA server.
      </description>
      <arg name="success" type="EmberAfOtaDownloadResult" description="This indicates the success or failure of the download and cryptographic verification process (if applicable)."/>
      <arg name="id" type="const EmberAfOtaImageId*" description="This is the image identifier information that corresponds to the download result."/>
      <codeForStub>
// At this point the image has been completely downloaded and cryptographic 
  // checks (if applicable) have been performed.

  if (!success) {
    emberAfOtaBootloadClusterPrintln("Download failed.");
    return true;   // return value is ignored
  }
  
  // This is for any additional validation that needs to be performed
  // on the image by the application.
  
  // The results of checks here will be returned back to the OTA server
  // in the Upgrade End request.
  return true;
       </codeForStub>
    </function>
<!-- NOTE:  This should be turned into a plugin callback instead of a generic callback.  But for now it is here (RBA).-->
    <function id="OTA_CLIENT_BOOTLOAD" name="Ota Client Bootload" returnType="void">
      <description>
        This callback is fired when the OTA Client recevies a command to bootload the newly downloaded OTA image.  This callback will perform the platform specific to bootload their device.
      </description>
      <arg name="id" type="const EmberAfOtaImageId*" description="This is the identifier relating to the image that has been downloaded and is ready for bootload."/>
      <codeForStub>
// Any final preperation prior to the bootload should be done here.
  // It is assumed that the device will reset in most all cases.
  // Please implement me.
      </codeForStub>
    </function>
<!-- NOTE:  This should be turned into a plugin callback instead of a generic callback.  But for now it is here (RBA).-->
    <function id="OTA_SERVER_QUERY" name="Ota Server Query" returnType="uint8_t">
      <description>
        This callback is fired when the OTA server receives a query request by the client.  The callback lets the server application indicate to the client what the 'next' version of software is for the device, or if there is not one available.
      </description>
      <arg name="currentImageId" type="const EmberAfOtaImageId*" description="This is the current software image that the client hase."/>
      <arg name="hardwareVersion" type="uint16_t*" description="If this value is non-NULL, it indicates the hardware version of the client device.  If NULL, the client did not specify a hardware version."/>
      <arg name="nextUpgradeImageId" type="EmberAfOtaImageId*" description="This is a pointer to a data structure containing the 'next' software version for the client to download."/>
      <codeForStub>
// If a new software image is available, this function should return EMBER_ZCL_STATUS_SUCCESS
  // and populate the 'nextUpgradeImageId' structure with the appropriate values.
  // If no new software image is available (i.e. the client should not download a firmware image)
  // then the server should return EMBER_ZCL_STATUS_NO_IMAGE_AVAILABLE.
  return EMBER_ZCL_STATUS_NO_IMAGE_AVAILABLE;
      </codeForStub>
    </function>
<!-- NOTE:  This should be turned into a plugin callback instead of a generic callback.  But for now it is here (RBA).-->
    <function id="OTA_SERVER_BLOCK_SIZE" name="Ota Server Block Size" returnType="uint8_t">
      <description>
        This function provides a way for the server to adjust the block size of its response to an Image block request by a client.
      </description>
      <arg name="clientNodeId" type="EmberNodeId" description="The node Id of OTA client making an image block request."/>
      <codeForStub>
// This function provides a way for the server to potentially
  // adjust the block size based on the client who is requesting.
  // In other words if we are using source routing we will limit
  // data returned by enough to put a source route into the message.

  // Image Block Response Message Format
  // Status Code: 1-byte
  // Manuf Code:  2-bytes
  // Image Type:  2-bytes
  // File Ver:    4-bytes
  // File Offset: 4-bytes
  // Data Size:   1-byte
  // Data:        variable
  const uint8_t IMAGE_BLOCK_RESPONSE_OVERHEAD = (EMBER_AF_ZCL_OVERHEAD + 14);

  EmberApsFrame apsFrame;
  uint8_t maxSize;
  apsFrame.options = EMBER_APS_OPTION_NONE;

  if (emberAfIsCurrentSecurityProfileSmartEnergy()) {
    apsFrame.options |= EMBER_APS_OPTION_ENCRYPTION;
  }

  maxSize = emberAfMaximumApsPayloadLength(EMBER_OUTGOING_DIRECT,
                                           clientNodeId,
                                           &amp;apsFrame);
  maxSize -= IMAGE_BLOCK_RESPONSE_OVERHEAD;
  return maxSize;
      </codeForStub>
    </function>
<!-- NOTE:  This should be turned into a plugin callback instead of a generic callback.  But for now it is here (RBA).-->
    <function id="OTA_SERVER_UPGRADE_END_REQUEST" name="Ota Server Upgrade End Request" returnType="bool">
      <description>
        This function is called when the OTA server receives a request an upgrade end request.  If the request indicated a successful download by the client, the server must tell the client when and if to upgrade to the downloaded image.  
      </description>
      <arg name="source" type="EmberNodeId" description="The node ID of the device that sent the upgrade end request."/>
      <arg name="status" type="uint8_t" description="This is the ZCL status sent by the client indicating the result of its attempt to download the new upgrade image.  If the status is not EMBER_ZCL_STATUS_SUCCESS then this callback is merely informative and no response mesasge will be generated by the server."/>
      <arg name="returnValue" type="uint32_t*" description="If the server returns true indicating that the client should apply the upgrade, this time value indicates when in the future the client should apply the upgrade."/>
      <arg name="imageId" type="const EmberAfOtaImageId*" description="This variable indicates the software version that the client successfully downloaded and is asking to upgrade to."/>
      <codeForStub>
// If the status value is not EMBER_ZCL_STATUS_SUCCESS, then this callback is
  // merely informative and no response message will be generated by the server.
  // If the server wants the client to NOT apply the upgrade, then it should
  // return false.
  // If the server wants the client to apply the upgrade, it should return true
  // and set the 'returnValue' parameter to when it wants the client to
  // apply the upgrade.  There are three possible values:
  //   0               =  Apply the upgrade now
  //   0xFFFFFFFF      =  Don't apply yet, ask again later.
  //   (anything-else) =  Apply the upgrade X minutes from now.
  *returnValue = 0;
  return true;
      </codeForStub>
    </function>
<!-- NOTE:  This should be turned into a plugin callback instead of a generic callback.  But for now it is here (RBA).-->
    <function id="OTA_PAGE_REQUEST_SERVER_POLICY" name="Ota Page Request Server Policy" returnType="uint8_t">
      <description>
        This callback is called by the OTA server page request code when it wants to determine if it is allowed for an OTA client to make a page request.  It is only called if page request support has been enabled on the server.  It should return EMBER_ZCL_STATUS_SUCCESS if it allows the page request, and EMBER_ZCL_STATUS_UNSUP_CLUSTER_COMMAND if it does not want to allow it.
      </description>
      <codeForStub>
return EMBER_ZCL_STATUS_SUCCESS;
      </codeForStub>
    </function>
    <function id="ENDPOINT_IN_GROUP" name="Endpoint In Group" returnType="bool" cluster="Groups" side="server">
      <description>
        This function is called by the framework when it needs to determine if an endpoint is a member of a group.  The application should return true if the endpoint is a member of the group and false otherwise.
      </description>
      <arg name="endpoint" type="uint8_t"  description="The endpoint." />
      <arg name="groupId"  type="uint16_t" description="The group identifier." />
      <codeForStub>
        return false;
      </codeForStub>
    </function>
    <function id="CLEAR_GROUP_TABLE" name="Clear Group Table" returnType="void" cluster="Groups" side="server">
      <description>
        This function is called by the framework when the application should clear the group table.
      </description>
      <arg name="endpoint" type="uint8_t"  description="The endpoint." />
      <codeForStub />
    </function>
    <function id="STORE_CURRENT_SCENE" name="Store Current Scene" returnType="EmberAfStatus" cluster="Scenes" side="server">
      <description>
        This function is called by the framework when the application should store the current scene.  If an entry already exists in the scene table with the same scene and group ids, the application should update the entry with the current scene.  Otherwise, a new entry should be adde to the scene table, if possible.
      </description>
      <arg name="endpoint" type="uint8_t" description="The endpoint." />
      <arg name="groupId" type="uint16_t" description="The group identifier." />
      <arg name="sceneId" type="uint8_t" description="The scene identifier." />
      <codeForStub>
        return EMBER_ZCL_STATUS_FAILURE;
      </codeForStub>
    </function>
    <function id="RECALL_SAVED_SCENE" name="Recall Saved Scene" returnType="EmberAfStatus" cluster="Scenes" side="server">
      <description>
        This function is called by the framework when the application should recall a saved scene.
      </description>
      <arg name="endpoint" type="uint8_t" description="The endpoint." />
      <arg name="groupId" type="uint16_t" description="The group identifier." />
      <arg name="sceneId" type="uint8_t" description="The scene identifier." />
      <codeForStub>
        return EMBER_ZCL_STATUS_FAILURE;
      </codeForStub>
    </function>
    <function id="CLEAR_SCENE_TABLE" name="ClearSceneTable" returnType="void" cluster="Scenes" side="server">
      <description>
        This function is called by the framework when the application should clear the scene table.
      </description>
      <arg name="endpoint" type="uint8_t"  description="The endpoint." />
      <codeForStub />
    </function>
    <function id="INTERPAN_SEND_MESSAGE" name="Interpan Send Message" returnType="EmberStatus">
      <description>
        This function will send a raw MAC message with interpan frame format using the passed parameters.
      </description>
      <arg name="header" type="EmberAfInterpanHeader*" description="Interpan header info"/>
      <arg name="messageLength" type="uint16_t" description="The length of the message received or to send"/>
      <arg name="message" type="uint8_t*" description="The message data received or to send."/>
      <codeForStub>
        return EMBER_LIBRARY_NOT_PRESENT;
      </codeForStub>
    </function>
    <function id="UNUSED_PAN_ID_FOUND" name="Unused Pan Id Found" returnType="void">
      <description>
        This is called by the framework on behalf of the form-and-join library to notify the application of the PAN id and channel found following a call to ::emberScanForUnusedPanId().  See form-and-join documentation for more information.
      </description>
      <arg name="panId"   type="EmberPanId" description="" />
      <arg name="channel" type="uint8_t"      description="" />
      <codeForStub />
    </function>
    <function id="SCAN_ERROR" name="Scan Error" returnType="void">
      <description>
        This is called by the framework on behalf of the form-and-join library to notify the application if an error occurs while scanning.  See form-and-join documentation for more information.
      </description>
      <arg name="status" type="EmberStatus" description="The status of the scan." />
      <codeForStub />
    </function>
    <function id="SCAN_COMPLETE" name="Scan Complete" returnType="void">
      <description>
        This is called by the low-level stack code when an 802.15.4 active scan completes.
      </description>
      <arg name="channel" type="uint8_t"      description="If the status indicates an error, the channel on which the error occurred.  Otherwise it is undefined for EMBER_SUCCESS."/>
      <arg name="status" type="EmberStatus" description="The status of the scan."/>
      <codeForStub/>
    </function>
    <function id="ENERGY_SCAN_RESULT" name="Energy Scan Result" returnType="void">
      <description>
        This is called by the low-level stack code when an 802.15.4 energy scan completes.
      </description>
      <arg name="channel" type="uint8_t" description="The channel where the energy scan took place."/>
      <arg name="rssi"    type="int8_t" description="The receive signal strength indicator for the channel."/>
      <codeForStub/>
    </function>
    <function id="NETWORK_FOUND" name="Network Found" returnType="void">
      <description>
        This callback is generated when an active scan finds a 802.15.4 network.
      </description>
      <arg name="networkFound" type="EmberZigbeeNetwork*" description="A struct containing information about the network found."/>
      <arg name="lqi"          type="uint8_t" description="The link quality indication of the network found."/>
      <arg name="rssi"         type="int8_t"  description="The received signal strength indication of the network found."/>
      <codeForStub/>
    </function>
    <function id="FIND_UNUSED_PAN_ID_AND_FORM" name="Find Unused Pan Id And Form" returnType="EmberStatus">
      <description>
        This function is called by the framework to search for an unused PAN id and form a new network.  The application should return EMBER_SUCCESS if the operation was initiated successfully.
      </description>
      <codeForStub>
        return EMBER_LIBRARY_NOT_PRESENT;
      </codeForStub>
    </function>
    <function id="START_SEARCH_FOR_JOINABLE_NETWORK" name="Start Search For Joinable Network" returnType="EmberStatus">
      <description>
        This function is called by the framework to search for joinable networks and join a network.  The application should return EMBER_SUCCESS if the operation was initiated successfully.
      </description>
      <codeForStub>
        return EMBER_LIBRARY_NOT_PRESENT;
      </codeForStub>
    </function>
    <function id="CLIENT_COMMAND_RECEIVED" name="Client Command Received" returnType="bool" cluster="Key Establishment" side="client">
      <description>
        This function is called by the application framework when a server-to-client key establishment command is received but has yet to be handled by the framework code.  This function should return a bool value indicating whether the command has been handled by the application code and should not be further processed by the framework.
      </description>
      <arg name="cmd" type="EmberAfClusterCommand *" />
      <codeForStub>
        return false;
      </codeForStub>
    </function>
    <function id="SERVER_COMMAND_RECEIVED" name="Server Command Received" returnType="bool" cluster="Key Establishment" side="server">
      <description>
        This function is called by the application framework when a client-to-server key establishment command is received but has yet to be handled by the framework code.  This function should return a bool value indicating whether the command has been handled by the application code and should not be further processed by the framework.
      </description>
      <arg name="cmd" type="EmberAfClusterCommand *" />
      <codeForStub>
        return false;
      </codeForStub>
    </function>
    <function id="CLUSTER_SECURITY_CUSTOM" name="Cluster Security Custom" returnType="bool">
      <description>
        This callback is fired when determining if APS encryption is required for a cluster outside of the specification's required clusters.  In other words, for the Smart Energy profile this would be a cluster beyond the list that normally requires APS encryption.
      </description>
      <arg name="profileId" type="EmberAfProfileId" description="The profile ID"/>
      <arg name="clusterId" type="EmberAfClusterId" description="The cluster ID"/>
      <arg name="incoming"  type="bool"          description="Whether this is an incoming or outgoing message."/>
      <arg name="commandId" type="uint8_t"            description="The ZCL command ID being sent/received."/>
      <codeForStub>
// By default, assume APS encryption is not required.
  return false;
      </codeForStub>
    </function>
    <function id="CONFIGURE_REPORTING_COMMAND" name="Configure Reporting Command" returnType="bool">
      <description>
        This function is called by the application framework when a Configure Reporting command is received from an external device.  The Configure Reporting command contains a series of attribute reporting configuration records.  The application should return true if the message was processed or false if it was not.
      </description>
      <arg name="cmd" type="const EmberAfClusterCommand *" />
      <codeForStub>
        return false;
      </codeForStub>
    </function>
    <function id="READ_REPORTING_CONFIGURATION_COMMAND" name="Read Reporting Configuration Command" returnType="bool">
      <description>
        This function is called by the application framework when a Read Reporting Configuration command is received from an external device.  The application should return true if the message was processed or false if it was not.
      </description>
      <arg name="cmd" type="const EmberAfClusterCommand *" />
      <codeForStub>
        return false;
      </codeForStub>
    </function>
    <function id="CLEAR_REPORT_TABLE" name="Clear Report Table" returnType="EmberStatus">
      <description>
        This function is called by the framework when the application should clear the report table.
      </description>
      <codeForStub>
        return EMBER_LIBRARY_NOT_PRESENT;
      </codeForStub>
    </function>
    <function id="REPORTING_ATTRIBUTE_CHANGE" name="Reporting Attribute Change" returnType="void">
      <description>
        This function is called by the framework when an attribute managed by the framework changes.  The application should call this function when an externally-managed attribute changes.  The application should use the change notification to inform its reporting decisions.
      </description>
      <arg name="endpoint"         type="uint8_t"                />
      <arg name="clusterId"        type="EmberAfClusterId"     />
      <arg name="attributeId"      type="EmberAfAttributeId"   />
      <arg name="mask"             type="uint8_t"                />
      <arg name="manufacturerCode" type="uint16_t"               />
      <arg name="type"             type="EmberAfAttributeType" />
      <arg name="data"             type="uint8_t *"              />
      <codeForStub />
    </function>
    <function id="NETWORK_KEY_UPDATE_COMPLETE" name="Network Key Update Complete" returnType="void">
      <description>
        This is called by the framework when a network key update operation started by the trust center is complete.
      </description>
      <arg name="status" type="EmberStatus"/>
      <codeForStub />
    </function>
    <function id="SCENES_CLUSTER_MAKE_INVALID" name="Make Invalid" returnType="EmberAfStatus" cluster="Scenes" side="server">
      <description>
        This function is called to invalidate the valid attribute in the Scenes cluster.
      </description>
      <arg name="endpoint" type="uint8_t" />
      <codeForStub>
        return EMBER_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
      </codeForStub>
    </function>
    <function id="ON_OFF_CLUSTER_SET_VALUE" name="Set Value" returnType="EmberAfStatus" cluster="On/off" side="server">
      <description>
        This function is called when the on/off value needs to be set, either through normal channels or as a result of a level change.
      </description>
      <arg name="endpoint"                 type="uint8_t"   />
      <arg name="command"                  type="uint8_t"   />
      <arg name="initiatedByLevelChange"   type="bool" />
      <codeForStub>
        return EMBER_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
      </codeForStub>
    </function>
    <function id="ON_OFF_CLUSTER_LEVEL_CONTROL_EFFECT" name="Level Control Effect" returnType="void" cluster="On/off" side="server">
      <description>
        This is called by the framework when the on/off cluster initiates a command that must effect a level control change. The implementation assumes that the client will handle any effect on the On/Off Cluster.
      </description>
      <arg name="endpoint" type="uint8_t"   />
      <arg name="newValue" type="bool" />
      <codeForStub />
    </function>
    <function id="ADD_TO_CURRENT_APP_TASKS" name="Add To Current App Tasks" returnType="void">
      <description>
        This function is only useful to sleepy end devices.  This function will note the passed item as part of a set of tasks the application has outstanding (e.g. message sent requiring APS acknwoledgement).  This will affect how the application behaves with regard to sleeping and polling.  Until the outstanding task is completed, the device may poll more frequently and sleep less often.
      </description>
      <arg name="tasks" type="EmberAfApplicationTask" />
      <codeForStub/>
    </function>
    <function id="REMOVE_FROM_CURRENT_APP_TASKS" name="Remove From Current App Tasks" returnType="void">
      <description>
        This function is only useful to sleepy end devices.  This function will remove the passed item from the set of tasks the application has outstanding (e.g. message sent requiring APS acknwoledgement).  This will affect how the application behaves with regard to sleeping and polling.  Removing the item from the list of outstanding tasks may allow the device to sleep longer and poll less frequently.  If there are other outstanding tasks the system may still have to stay away and poll more often.
      </description>
      <arg name="tasks" type="EmberAfApplicationTask" />
      <codeForStub/>
    </function>
    <function id="GET_CURRENT_APP_TASKS" name="Get Current App Tasks" returnType="EmberAfApplicationTask">
      <description>
        This function is only useful to sleepy end devices.  This function will return the set of tasks the application has outstanding.  These tasks affect how the application behaves with regard to sleeping and polling.
      </description>
      <codeForStub>
        return 0;
      </codeForStub>
    </function>
    <function id="GET_LONG_POLL_INTERVAL_MS" name="Get Long Poll Interval Ms" returnType="uint32_t">
      <description>
        This function is only useful to end devices.  This function will return the long poll interval (in milliseconds) for the current network.  This interval is the maximum amount of time a child will wait between polls of its parent when it is not expecting data.
      </description>
      <codeForStub>
        return 0;
      </codeForStub>
    </function>
    <function id="GET_LONG_POLL_INTERVAL_QS" name="Get Long Poll Interval Qs" returnType="uint32_t">
      <description>
        This function is only useful to end devices.  This function will return the long poll interval (in quarter seconds) for the current network.  This interval is the maximum amount of time a child will wait between polls of its parent when it is not expecting data.
      </description>
      <codeForStub>
        return 0;
      </codeForStub>
    </function>
    <function id="SET_LONG_POLL_INTERVAL_MS" name="Set Long Poll Interval Ms" returnType="void">
      <description>
        This function is only useful to end devices.  This function will set the long poll interval (in milliseconds) for the current network.  This interval is the maximum amount of time a child will wait between polls of its parent when it is not expecting data.
      </description>
      <arg name="longPollIntervalMs" type="uint32_t" />
      <codeForStub />
    </function>
    <function id="SET_LONG_POLL_INTERVAL_QS" name="Set Long Poll Interval Qs" returnType="void">
      <description>
        This function is only useful to end devices.  This function will set the long poll interval (in quarter seconds) for the current network.  This interval is the maximum amount of time a child will wait between polls of its parent when it is not expecting data.
      </description>
      <arg name="longPollIntervalQs" type="uint32_t" />
      <codeForStub />
    </function>
    <function id="GET_SHORT_POLL_INTERVAL_MS" name="Get Short Poll Interval Ms" returnType="uint16_t">
      <description>
        This function is only useful to sleepy end devices.  This function will return the short poll interval (in milliseconds) for the current network.  This interval is the maximum amount of time a child will wait between polls of its parent when it is expecting data.
      </description>
      <codeForStub>
        return 0;
      </codeForStub>
    </function>
    <function id="GET_SHORT_POLL_INTERVAL_QS" name="Get Short Poll Interval Qs" returnType="uint16_t">
      <description>
        This function is only useful to sleepy end devices.  This function will return the short poll interval (in quarter seconds) for the current network.  This interval is the maximum amount of time a child will wait between polls of its parent when it is expecting data.
      </description>
      <codeForStub>
        return 0;
      </codeForStub>
    </function>
    <function id="SET_SHORT_POLL_INTERVAL_MS" name="Set Short Poll Interval Ms" returnType="void">
      <description>
        This function is only useful to sleepy end devices.  This function will set the short poll interval (in milliseconds) for the current network.  This interval is the maximum amount of time a child will wait between polls of its parent when it is expecting data.
      </description>
      <arg name="shortPollIntervalMs" type="uint16_t" />
      <codeForStub />
    </function>
    <function id="SET_SHORT_POLL_INTERVAL_QS" name="Set Short Poll Interval Qs" returnType="void">
      <description>
        This function is only useful to sleepy end devices.  This function will set the short poll interval (in quarter seconds) for the current network.  This interval is the maximum amount of time a child will wait between polls of its parent when it is expecting data.
      </description>
      <arg name="shortPollIntervalQs" type="uint16_t" />
      <codeForStub />
    </function>
    <function id="GET_CURRENT_POLL_INTERVAL_MS" name="Get Current Poll Interval Ms" returnType="uint32_t">
      <description>
        This function is only useful to end devices.  This function will return the current poll interval (in milliseconds) for the current network.  This interval is the maximum amount of time a child is currently waiting between polls of its parent.
      </description>
      <codeForStub>
        return 0;
      </codeForStub>
    </function>
    <function id="GET_CURRENT_POLL_INTERVAL_QS" name="Get Current Poll Interval Qs" returnType="uint32_t">
      <description>
        This function is only useful to end devices.  This function will return the current poll interval (in quarter seconds) for the current network.  This interval is the maximum amount of time a child is currently waiting between polls of its parent.
      </description>
      <codeForStub>
        return 0;
      </codeForStub>
    </function>
    <function id="GET_WAKE_TIMEOUT_MS" name="Get Wake Timeout Ms" returnType="uint16_t">
      <description>
        This function is only useful to sleepy end devices.  This function will return the wake timeout (in milliseconds) for the current network.  This timeout is the maximum amount of time a child will wait for a task in the wake bitmask to finish.  While waiting, the device will short poll.
      </description>
      <codeForStub>
        return 0;
      </codeForStub>
    </function>
    <function id="GET_WAKE_TIMEOUT_QS" name="Get Wake Timeout Qs" returnType="uint16_t">
      <description>
        This function is only useful to sleepy end devices.  This function will return the wake timeout (in quarter seconds) for the current network.  This timeout is the maximum amount of time a child will wait for a task in the wake bitmask to finish.  While waiting, the device will short poll.
      </description>
      <codeForStub>
        return 0;
      </codeForStub>
    </function>
    <function id="SET_WAKE_TIMEOUT_MS" name="Set Wake Timeout Ms" returnType="void">
      <description>
        This function is only useful to sleepy end devices.  This function will set the wake timeout (in milliseconds) for the current network.  This timeout is the maximum amount of time a child will wait for a task in the wake bitmask to finish.  While waiting, the device will short poll.
      </description>
      <arg name="wakeTimeoutMs" type="uint16_t" />
      <codeForStub />
    </function>
    <function id="SET_WAKE_TIMEOUT_QS" name="Set Wake Timeout Qs" returnType="void">
      <description>
        This function is only useful to sleepy end devices.  This function will set the wake timeout (in quarter seconds) for the current network.  This timeout is the maximum amount of time a child will wait for a task in the wake bitmask to finish.  While waiting, the device will short poll.
      </description>
      <arg name="wakeTimeoutQs" type="uint16_t" />
      <codeForStub />
    </function>
    <function id="GET_WAKE_TIMEOUT_BITMASK" name="Get Wake Timeout Bitmask" returnType="EmberAfApplicationTask">
      <description>
        This function is only useful to sleepy end devices.  This function will return the wake timeout bitmask for the current network.  The bitmask determines which tasks will timeout automatically and which tasks require manual removal from the task list.
      </description>
      <codeForStub>
        return 0;
      </codeForStub>
    </function>
    <function id="SET_WAKE_TIMEOUT_BITMASK" name="Set Wake Timeout Bitmask" returnType="void">
      <description>
        This function is only useful to sleepy end devices.  This function will set the wake timeout bitmask for the current network.  The bitmask determines which tasks will timeout automatically and which tasks require manual removal from the task list.
      </description>
      <arg name="tasks" type="EmberAfApplicationTask" />
      <codeForStub />
    </function>
    <function id="GET_CURRENT_POLL_CONTROL" name="Get Current Poll Control" returnType="EmberAfEventPollControl">
      <description>
        This function will retrieve the current poll control that the system is using for the current network.  This is determined by examining all the scheduled events and obtaining the most restrictive poll control context across all events.  The most restrictive poll control is EMBER_AF_SHORT_POLL followed by EMBER_AF_LONG_POLL.
      </description>
      <codeForStub>
        return EMBER_AF_LONG_POLL;
      </codeForStub>
    </function>
    <function id="GET_DEFAULT_POLL_CONTROL" name="Get Default Poll Control" returnType="EmberAfEventPollControl">
      <description>
        This function will retrieve the default poll control for the current network as previously set by emberAfSetDefaultPollControlCallback().  The default poll control will limit whether the network can long poll.
      </description>
      <codeForStub>
        return EMBER_AF_LONG_POLL;
      </codeForStub>
    </function>
    <function id="SET_DEFAULT_POLL_CONTROL" name="Set Default Poll Control" returnType="void">
      <description>
        This function will set the default poll control for the current network to control whether or not it can long poll.
      </description>
      <arg name="control" type="EmberAfEventPollControl"/>
      <codeForStub/>
    </function>
    <function id="GET_CURRENT_SLEEP_CONTROL" name="Get Current Sleep Control" returnType="EmberAfEventSleepControl">
      <description>
        This function will retrieve the current sleep control that the system is using.  This is determined by examining all the scheduled events and obtaining the most restrictive sleep control context across all events.  The most restrictive sleep control is EMBER_AF_STAY_AWAKE followed by EMBER_AF_OK_TO_SLEEP.
      </description>
      <codeForStub>
        return EMBER_AF_OK_TO_SLEEP;
      </codeForStub>
    </function>
    <function id="GET_DEFAULT_SLEEP_CONTROL" name="Get Default Sleep Control" returnType="EmberAfEventSleepControl">
      <description>
        This function will retrieve the default sleep control the system is using as previously set by emberAfSetDefaultSleepControlCallback().  The default sleep control will limit whether the device can sleep.
      </description>
      <codeForStub>
        return EMBER_AF_OK_TO_SLEEP;
      </codeForStub>
    </function>
    <function id="SET_DEFAULT_SLEEP_CONTROL" name="Set Default Sleep Control" returnType="void">
      <description>
        This function will set the default behavior of a sleeping device to control whether or not it must stay awake.  A device that stays awake does not sleep at all.  Otherwise, the device can sleep between events when appropriate.
      </description>
      <arg name="control" type="EmberAfEventSleepControl"/>
      <codeForStub/>
    </function>
    <function id="PRE_NCP_RESET" name="Pre Ncp Reset" returnType="void">
      <description>
        This function will be called prior to the reset of the NCP by the host.
      </description>
      <codeForStub/>
    </function>
    <function id="NCP_IS_AWAKE_ISR" name="Ncp Is Awake Isr" returnType="void">
      <description>
        This function is called IN ISR CONTEXT.  It notes that the NCP is awake after sleeping.  Care should be taken to do minimal processing in this ISR handler function.
      </description>
      <codeForStub/>
    </function>
    <function id="START_MOVE" name="Start Move" returnType="bool">
      <description>
        This function is called to initiate the process for a device to move (rejoin) to a new parent.
      </description>
      <codeForStub>
      return false;
      </codeForStub>
    </function>
    <function id="STOP_MOVE" name="Stop Move" returnType="void">
      <description>
        This function is called to cancel a previously scheduled move (rejoin) to a new parent.
      </description>
      <codeForStub/>
    </function>
    <function id="MAIN_START" name="Main Start" returnType="bool">
      <description>
        This function is called at the start of main after the HAL has been initialized.  The standard main function arguments of argc and argv are passed in.  However not all platforms have support for main() function arguments.  Those that do not are passed NULL for argv, therefore argv should be checked for NULL before using it.  If the callback determines that the program must exit, it should return true.  The value returned by main() will be the value written to the returnCode pointer.  Otherwise the callback should return false to let normal execution continue.
      </description>
      <arg name="returnCode" type="int*"/>
      <arg name="argc"      type="int"/>
      <arg name="argv"      type="char**"/>
      <codeForStub>
  // NOTE:  argc and argv may not be supported on all platforms, so argv MUST be
  // checked for NULL before referencing it.  On those platforms without argc 
  // and argv "0" and "NULL" are passed respectively.

  return false;  // exit?
      </codeForStub>
    </function>
    <function id="SECURITY_INIT" name="Security Init" returnType="void">
      <description>
        This callback is called by the framework to give the application a chance to modify the security settings of the node during network initialization.  Depending on the context when this callback is called, the pointer to the initial security state may be NULL, which means the initial security state can no longer be modified as the node is already operating on the network.
      </description>
      <arg name="state"       type="EmberInitialSecurityState *" />
      <arg name="extended"    type="EmberExtendedSecurityBitmask *" />
      <arg name="trustCenter" type="bool" />
      <codeForStub />
    </function>
    <function id="GET_FORM_AND_JOIN_EXTENDED_PAN_ID" name="Get Form And Join Extended Pan Id" returnType="void">
      <description>
        This callback is called by the framework to get the extended PAN ID used by the current network for forming and joining.  The extended PAN ID used for forming and joining is not necessarily the same extended PAN ID actually in use on the network.
      </description>
      <arg name="resultLocation" type="uint8_t *" />
      <codeForStub />
    </function>
    <function id="SET_FORM_AND_JOIN_EXTENDED_PAN_ID" name="Set Form And Join Extended Pan Id" returnType="void">
      <description>
        This callback is called by the framework to set the extended PAN ID used by the current network for forming and joining.  The extended PAN ID used for forming and joining is not necessarily the same extended PAN ID actually in use on the network.
      </description>
      <arg name="extendedPanId" type="const uint8_t *" />
      <codeForStub />
    </function>
    <function id="EEPROM_INIT" name="Eeprom Init" returnType="void">
      <description>
        Tells the system to initialize the EEPROM if it is not already initialized.
      </description>
      <codeForStub/>
    </function>
    <function id="EEPROM_SHUTDOWN" name="Eeprom Shutdown" returnType="void">
      <description>
        Tells the system to shutdown the EEPROM if it is not already shutdown.
      </description>
      <codeForStub/>
    </function>
   <function id="EEPROM_NOTE_INITIALIZED_STATE" name="Eeprom Note Initialized State" returnType="void">
      <description>
        Records the state of the EEPROM so that an intelligent driver (like the EEPROM plugin) can re-initialize the driver prior to any calls to it.
      </description>
      <arg name="state" type="bool" description="The state of the EEPROM, false=re-initalization needed, true=no-re-init needed"/>
      <codeForStub/>
    </function>
    <function id="REMOVE_SCENES_IN_GROUP" name="Remove Scenes In Group" returnType="void" cluster="Scenes" side="server">
      <description> This function removes the scenes from a specified group.
      </description>
      <arg name="endpoint"  type="uint8_t"   description="Endpoint"   />
      <arg name="groupId"   type="uint16_t"  description="Group ID"   />
      <codeForStub/>
    </function>
    <function id="REMOTE_SET_BINDING" name="Remote Set Binding Permission" returnType="EmberStatus">
      <description>
        This function is called by the framework to request permission to service the remote set binding request. Return EMBER_SUCCESS to allow request, anything else to disallow request.
      </description>
      <arg name="entry"  type="const EmberBindingTableEntry *"   description="Ember Binding Tablet Entry"   />
      <codeForStub>
        return EMBER_SUCCESS; // default
      </codeForStub>
    </function>
    <function id="REMOTE_DELETE_BINDING" name="Remote Delete Binding Permission" returnType="EmberStatus">
      <description>
        This function is called by the framework to request permission to service the remote delete binding request. Return EMBER_SUCCESS to allow request, anything else to disallow request.
      </description>
      <arg name="index"  type="uint8_t"   description="index to an Ember binding table entry"   />
      <codeForStub>
        return EMBER_SUCCESS; // default
      </codeForStub>
    </function>
    <function id="GET_SOURCE_ROUTE_OVERHEAD" name="Get Source Route Overhead" returnType="uint8_t">
      <description>
        This function is called by the framework to determine the overhead required in the network frame for source routing to a particular destination.
      </description>
      <arg name="destination" type="EmberNodeId" description="The node id of the destination" />
      <codeForStub>
        return 0;
      </codeForStub>
    </function>
    <function id="SET_SOURCE_ROUTE_OVERHEAD" name="Set Source Route Overhead" returnType="void">
      <description>
        This function is called by the framework when it has information about the source route overhead to a particular destination. The application may use this information to cache the source route overhead.
      </description>
      <arg name="destination" type="EmberNodeId" description="The node id of the destination" />
      <arg name="overhead"    type="uint8_t"       description="The overhead in bytes" />
      <codeForStub />
    </function>
    <function id="PRE_MESSAGE_SEND" name="Pre Message Send" returnType="bool">
      <description>
        This function is called by the framework when it is about to pass a message to the stack primitives for sending.   This message may or may not be ZCL, ZDO, or some other protocol.  This is called prior to
        any ZigBee fragmentation that may be done.  If the function returns true it is assumed the callback has consumed and processed the message.  The callback must also set the EmberStatus status code to be passed back to the caller.  The framework will do no further processing on the message.
        If the function returns false then it is assumed that the callback has not processed the mesasge and the framework will continue to process accordingly.
      </description>
      <arg name="messageStruct" type="EmberAfMessageStruct*" description="The structure containing the parameters of the APS message to be sent."/>
      <arg name="status" type="EmberStatus*" description="A pointer to the status code value that will be returned to the caller."/>
      <codeForStub>
        return false;
      </codeForStub>
    </function>
    <function id="GET_ENDPOINT_INFO" name="Get Endpoint Info" returnType="bool">
      <description>
        This function is a callback to an application implemented endpoint that operates outside the normal application framework.  When the framework wishes to perform operations with that endpoint it uses this callback to retrieve the endpoint's information.  If the endpoint exists and the application can provide data then true shall be returned.  Otherwise the callback must return false.
      </description>
      <arg name="endpoint"           type="uint8_t"  description="The endpoint to retrieve data for."/>
      <arg name="returnNetworkIndex" type="uint8_t*" description="The index corresponding to the ZigBee network the endpoint belongs to.  If not using a multi-network device, 0 must be returned.  Otherwise on a multi-network device the stack will switch to this network before sending the message."/>
      <arg name="returnEndpointInfo" type="EmberAfEndpointInfoStruct*" description="A pointer to a data struct that will be written with information about the endpoint."/>
      <codeForStub>
        return false;
      </codeForStub>
    </function> 
    <function id="PRE_CLI_SEND" name="Pre Cli Send" returnType="bool">
      <description>
        This function is called by the framework when it is about to pass a message constructed over CLI to the stack primitives for sending. If the function returns true it is assumed that the callback has consumed and processed the message. The framework will not do any further processing on the message.
        If the function returns false then it is assumed that the callback has not processed the message and the framework will continue to process accordingly.
      </description>
      <arg name="apsFrame" type="EmberApsFrame*" description="The structure containing the APS frame"/>
      <arg name="source" type="EmberNodeId" description="Source Node Id"/>
      <arg name="destination" type="EmberNodeId" description="Destintion Node Id"/>
      <arg name="message" type="uint8_t*" description="Pointer to the message payload"/>
      <arg name="messageLength" type="uint16_t" description="Length of the message payload"/>
      <codeForStub>
        return false;
      </codeForStub>
    </function>
<!--     <function id="CLI_INTERNET_SERVER_SEND" name="Cli Internet Server Send" returnType="bool">
      <description>
        This function is called by the framework when it wants to send a CLI constructed ZCL packet over IP.
      </description>
      <arg name="apsFrame" type="EmberApsFrame*" description="The structure containing the APS frame"/>
      <arg name="destinationEUI" type="EmberEUI64" description="Destintion EUI64"/>
      <arg name="message" type="uint8_t*" description="Pointer to the message payload"/>
      <arg name="messageLength" type="uint16_t" description="Length of the message payload"/>
      <codeForStub>
        return false;
      </codeForStub>
    </function> -->
    <function id="HAL_BUTTON_ISR" name="Hal Button Isr" returnType="void">
      <description>
        This callback is called by the framework whenever a button is pressed on the device. This callback is called within ISR context.
      </description>
      <arg name="button" type="uint8_t" description="The button which has changed state, either BUTTON0 or BUTTON1 as defined in the appropriate BOARD_HEADER." />
      <arg name="state"  type="uint8_t" description="The new state of the button referenced by the button parameter, either ::BUTTON_PRESSED if the button has been pressed or ::BUTTON_RELEASED if the button has been released." />
      <codeForStub />
    </function>
    <function id="GET_ENDPOINT_DESCRIPTION" name="Get Endpoint Description" returnType="bool">
      <description>
        This callback is called by the framework whenever it receives a ZDO request to enumerate the details about an endpoint.  By default the framework provides the information based on the precompiled endpoint information as defined in AppBuilder.  This callback can override that behavior at runtime and return different information.  If the endpoint information is being overridden then the callback must return true.  Otherwise it should return false, which allows the framework to perform its default behavior.  This is only applicable to SOC devices.
      </description>
      <arg name="endpoint" type="uint8_t" description="The endpoint number that is being queried."/>
      <arg name="result"   type="EmberEndpointDescription*" description="This is a pointer to a data structure where the endpoint information is written if the callback is providing the information."/>
      <codeForStub>
        return false;
      </codeForStub>
    </function>
    <function id="GET_ENDPOINT_BY_INDEX" name="Get Endpoint By Index" returnType="bool">
      <description>
        Get the endpoint number based on the passed index.  By default the framework handles this by managing endpoints based on the precompiled configuration defined in AppBuilder.  This callback can override this behavior at runtime and provide additional endpoints or different data than the compiled values.  If the index is overridden than the callback shall return true and set the endpointReturn parameter accordingly. A value of 0xFF means the endpoint doesn't exist at that index.
        Otherwise false must be returned by the callback and the default framework behavior will be executed.  This is only applicable to the SOC devices.
      </description>
      <arg name="index" type="uint8_t" description="The index of the endpoint."/>
      <arg name="endpointReturn" type="uint8_t*" description="The value of endpoint."/>
      <codeForStub>
        return false;
      </codeForStub>
    </function>
    <function id="ZIGBEE_KEY_ESTABLISHMENT" name="Zigbee Key Establishment" returnType="void">
      <description>
        A callback to the application to notify it of the status of the request for a Link Key.
      </description>
      <arg name="partner" type="EmberEUI64" description="partner The IEEE address of the partner device.  Or all zeros if the Key establishment failed."/>
      <arg name="status" type="EmberKeyStatus" description="The status of the key establishment."/>
      <codeForStub />
    </function>
    <function id="CAME_BACK_FROM_EM4" name="came back from EM4"
        returnType="void">
        <description>
            This callback would be implemented in idle/sleep
            plugin by the name emberAfCameBackFromEM4Callback and
            will be called by the framework. It lets the
            plugin/app know the board is back from EM4. So if the
            app wants to restore something, it can do it.
        </description>
    </function>
  </callback>
</configurator>
