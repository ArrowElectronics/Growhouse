<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Gecko Bootloader API Reference: Application Storage Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Gecko Bootloader API Reference
   &#160;<span id="projectnumber">bootloader-v1.8.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>API&#160;Documentation</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="http://www.silabs.com"><span>silabs.com</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__StorageInterface.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Application Storage Interface<div class="ingroups"><a class="el" href="group__Interface.html">Application Interface</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>Application interface for interfacing with the bootloader storage. </p>
<p>The Storage Interface is only available on bootloaders that declare they support <a class="el" href="group__CommonInterface.html#ga23fd85788bda58ea6e4f28eab4b74539">BOOTLOADER_CAPABILITY_STORAGE</a>. </p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for Application Storage Interface:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<center><table><tr><td><img src="group__StorageInterface.png" border="0" alt="" usemap="#group____StorageInterface"/>
<map name="group____StorageInterface" id="group____StorageInterface">
<area shape="rect" id="node2" href="group__Interface.html" title="Application interface to the bootloader. " alt="" coords="5,13,157,39"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBootloaderStorageSlot__t.html">BootloaderStorageSlot_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about a storage slot.  <a href="structBootloaderStorageSlot__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBootloaderStorageImplementationInformation__t.html">BootloaderStorageImplementationInformation_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about the bootloader storage implementation.  <a href="structBootloaderStorageImplementationInformation__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBootloaderStorageInformation__t.html">BootloaderStorageInformation_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about the bootloader storage.  <a href="structBootloaderStorageInformation__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBootloaderEraseStatus__t.html">BootloaderEraseStatus_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase status struct.  <a href="structBootloaderEraseStatus__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBootloaderStorageFunctions.html">BootloaderStorageFunctions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage API accessible from the application.  <a href="structBootloaderStorageFunctions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaa3ec112096e9442dff6c12b3adf7b7ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa3ec112096e9442dff6c12b3adf7b7ca"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StorageInterface.html#gaa3ec112096e9442dff6c12b3adf7b7ca">BOOTLOADER_STORAGE_IMPL_INFO_VERSION</a>&#160;&#160;&#160;(0x0201)</td></tr>
<tr class="memdesc:gaa3ec112096e9442dff6c12b3adf7b7ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current version of the <a class="el" href="structBootloaderStorageImplementationInformation__t.html" title="Information about the bootloader storage implementation. ">BootloaderStorageImplementationInformation_t</a> struct. <br /></td></tr>
<tr class="separator:gaa3ec112096e9442dff6c12b3adf7b7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f4839ed2d057841b664d9b3a26f5246"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1f4839ed2d057841b664d9b3a26f5246"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StorageInterface.html#ga1f4839ed2d057841b664d9b3a26f5246">BOOTLOADER_STORAGE_IMPL_INFO_VERSION_MAJOR</a>&#160;&#160;&#160;(0x0200)</td></tr>
<tr class="memdesc:ga1f4839ed2d057841b664d9b3a26f5246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Major version of the <a class="el" href="structBootloaderStorageImplementationInformation__t.html" title="Information about the bootloader storage implementation. ">BootloaderStorageImplementationInformation_t</a> struct. <br /></td></tr>
<tr class="separator:ga1f4839ed2d057841b664d9b3a26f5246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2d221e19a293930ec7b2e915c21708b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac2d221e19a293930ec7b2e915c21708b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StorageInterface.html#gac2d221e19a293930ec7b2e915c21708b">BOOTLOADER_STORAGE_IMPL_INFO_VERSION_MAJOR_MASK</a>&#160;&#160;&#160;(0xFF00)</td></tr>
<tr class="memdesc:gac2d221e19a293930ec7b2e915c21708b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Major version mask for <a class="el" href="group__StorageInterface.html#gaa3ec112096e9442dff6c12b3adf7b7ca">BOOTLOADER_STORAGE_IMPL_INFO_VERSION</a>. <br /></td></tr>
<tr class="separator:gac2d221e19a293930ec7b2e915c21708b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga329ca9f415fb1ba646d86eb67344f82a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga329ca9f415fb1ba646d86eb67344f82a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StorageInterface.html#ga329ca9f415fb1ba646d86eb67344f82a">BOOTLOADER_STORAGE_IMPL_CAPABILITY_ERASE_SUPPORTED</a>&#160;&#160;&#160;(1 &lt;&lt; 0)</td></tr>
<tr class="memdesc:ga329ca9f415fb1ba646d86eb67344f82a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spiflash capability indicating that it supports erase. <br /></td></tr>
<tr class="separator:ga329ca9f415fb1ba646d86eb67344f82a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c8c8994d789e65d91aa9c5e0eea7f94"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2c8c8994d789e65d91aa9c5e0eea7f94"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StorageInterface.html#ga2c8c8994d789e65d91aa9c5e0eea7f94">BOOTLOADER_STORAGE_IMPL_CAPABILITY_PAGE_ERASE_REQUIRED</a>&#160;&#160;&#160;(1 &lt;&lt; 1)</td></tr>
<tr class="memdesc:ga2c8c8994d789e65d91aa9c5e0eea7f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spiflash capability indicating it requires full page erases before new data can be written. <br /></td></tr>
<tr class="separator:ga2c8c8994d789e65d91aa9c5e0eea7f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ec762d826e7358a9e099a0fec71fd09"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1ec762d826e7358a9e099a0fec71fd09"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StorageInterface.html#ga1ec762d826e7358a9e099a0fec71fd09">BOOTLOADER_STORAGE_IMPL_CAPABILITY_BLOCKING_WRITE</a>&#160;&#160;&#160;(1 &lt;&lt; 2)</td></tr>
<tr class="memdesc:ga1ec762d826e7358a9e099a0fec71fd09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spiflash capability indicating that the write function is blocking. <br /></td></tr>
<tr class="separator:ga1ec762d826e7358a9e099a0fec71fd09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1b14dc36ecc7926f556019332c02808"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab1b14dc36ecc7926f556019332c02808"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StorageInterface.html#gab1b14dc36ecc7926f556019332c02808">BOOTLOADER_STORAGE_IMPL_CAPABILITY_BLOCKING_ERASE</a>&#160;&#160;&#160;(1 &lt;&lt; 3)</td></tr>
<tr class="memdesc:gab1b14dc36ecc7926f556019332c02808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spiflash capability indicating that the erase function is blocking. <br /></td></tr>
<tr class="separator:gab1b14dc36ecc7926f556019332c02808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1775031079e1d33177fe3ac48a732336"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1775031079e1d33177fe3ac48a732336"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StorageInterface.html#ga1775031079e1d33177fe3ac48a732336">BOOTLOADER_STORAGE_VERIFICATION_CONTEXT_SIZE</a>&#160;&#160;&#160;(384)</td></tr>
<tr class="memdesc:ga1775031079e1d33177fe3ac48a732336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context size for bootloader verification context. <br /></td></tr>
<tr class="separator:ga1775031079e1d33177fe3ac48a732336"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaa89e144ac8860e6438fa05de6ef4339c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa89e144ac8860e6438fa05de6ef4339c"></a>
typedef struct <a class="el" href="structBootloaderStorageFunctions.html">BootloaderStorageFunctions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StorageInterface.html#gaa89e144ac8860e6438fa05de6ef4339c">BootloaderStorageFunctions_t</a></td></tr>
<tr class="memdesc:gaa89e144ac8860e6438fa05de6ef4339c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage API accessible from the application. <br /></td></tr>
<tr class="separator:gaa89e144ac8860e6438fa05de6ef4339c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gac5a52f72db78d655840177f0e034d37c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StorageInterface.html#gac5a52f72db78d655840177f0e034d37c">BootloaderStorageType_t</a> { <br />
&#160;&#160;<a class="el" href="group__StorageInterface.html#ggac5a52f72db78d655840177f0e034d37caaf1113ff5007b46ad4e50ef301ed299b">SPIFLASH</a>, 
<br />
&#160;&#160;<a class="el" href="group__StorageInterface.html#ggac5a52f72db78d655840177f0e034d37ca5e341ba74bb0afd21095eabe0f8eba9b">INTERNAL_FLASH</a>, 
<br />
&#160;&#160;<a class="el" href="group__StorageInterface.html#ggac5a52f72db78d655840177f0e034d37caf9a807703d9b9e307e6cde5ac7a63164">CUSTOM_STORAGE</a>
<br />
 }<tr class="memdesc:gac5a52f72db78d655840177f0e034d37c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible storage types.  <a href="group__StorageInterface.html#gac5a52f72db78d655840177f0e034d37c">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gac5a52f72db78d655840177f0e034d37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gafc4cc80fcbb0bfea595915b11a6b5828"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StorageInterface.html#gafc4cc80fcbb0bfea595915b11a6b5828">bootloader_getStorageInfo</a> (<a class="el" href="structBootloaderStorageInformation__t.html">BootloaderStorageInformation_t</a> *info)</td></tr>
<tr class="separator:gafc4cc80fcbb0bfea595915b11a6b5828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08d0906c70cd68f8119b8f11319cc5ff"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StorageInterface.html#ga08d0906c70cd68f8119b8f11319cc5ff">bootloader_getStorageSlotInfo</a> (uint32_t slotId, <a class="el" href="structBootloaderStorageSlot__t.html">BootloaderStorageSlot_t</a> *slot)</td></tr>
<tr class="separator:ga08d0906c70cd68f8119b8f11319cc5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd7f4e8b6bba7fd8689a9a2da9511afd"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StorageInterface.html#gacd7f4e8b6bba7fd8689a9a2da9511afd">bootloader_readStorage</a> (uint32_t slotId, uint32_t offset, uint8_t *buffer, size_t length)</td></tr>
<tr class="separator:gacd7f4e8b6bba7fd8689a9a2da9511afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86dae5018d8726a68dd826240d8f2c52"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StorageInterface.html#ga86dae5018d8726a68dd826240d8f2c52">bootloader_writeStorage</a> (uint32_t slotId, uint32_t offset, uint8_t *buffer, size_t length)</td></tr>
<tr class="separator:ga86dae5018d8726a68dd826240d8f2c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafec82c0010c632b0c9cecc1cdf393cc2"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StorageInterface.html#gafec82c0010c632b0c9cecc1cdf393cc2">bootloader_eraseWriteStorage</a> (uint32_t slotId, uint32_t offset, uint8_t *buffer, size_t length)</td></tr>
<tr class="separator:gafec82c0010c632b0c9cecc1cdf393cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae14880e1483f25bd67f1b96e5345862f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StorageInterface.html#gae14880e1483f25bd67f1b96e5345862f">bootloader_eraseStorageSlot</a> (uint32_t slotId)</td></tr>
<tr class="separator:gae14880e1483f25bd67f1b96e5345862f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf73aff5099338a5ecf5d38197dfee5d3"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StorageInterface.html#gaf73aff5099338a5ecf5d38197dfee5d3">bootloader_initChunkedEraseStorageSlot</a> (uint32_t slotId, <a class="el" href="structBootloaderEraseStatus__t.html">BootloaderEraseStatus_t</a> *eraseStat)</td></tr>
<tr class="separator:gaf73aff5099338a5ecf5d38197dfee5d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa00cc123780c7655385b8c7b6a9f6e31"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StorageInterface.html#gaa00cc123780c7655385b8c7b6a9f6e31">bootloader_chunkedEraseStorageSlot</a> (<a class="el" href="structBootloaderEraseStatus__t.html">BootloaderEraseStatus_t</a> *eraseStat)</td></tr>
<tr class="separator:gaa00cc123780c7655385b8c7b6a9f6e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e20baecb19424efaa667248b851d991"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StorageInterface.html#ga8e20baecb19424efaa667248b851d991">bootloader_setImagesToBootload</a> (int32_t *slotIds, size_t length)</td></tr>
<tr class="separator:ga8e20baecb19424efaa667248b851d991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb9569405337cf6a8bec987bf96705c7"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StorageInterface.html#gafb9569405337cf6a8bec987bf96705c7">bootloader_getImagesToBootload</a> (int32_t *slotIds, size_t length)</td></tr>
<tr class="separator:gafb9569405337cf6a8bec987bf96705c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga833f0a3ed32c054d48e564d2fd5082aa"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StorageInterface.html#ga833f0a3ed32c054d48e564d2fd5082aa">bootloader_appendImageToBootloadList</a> (int32_t slotId)</td></tr>
<tr class="separator:ga833f0a3ed32c054d48e564d2fd5082aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4c61349c24dca22a52ba3de71ffe7ee"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StorageInterface.html#gaf4c61349c24dca22a52ba3de71ffe7ee">bootloader_setImageToBootload</a> (int32_t slotId)</td></tr>
<tr class="separator:gaf4c61349c24dca22a52ba3de71ffe7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad375581d8a53e23db490a4bc0e9a9fb2"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StorageInterface.html#gad375581d8a53e23db490a4bc0e9a9fb2">bootloader_initVerifyImage</a> (uint32_t slotId, void *context, size_t contextSize)</td></tr>
<tr class="separator:gad375581d8a53e23db490a4bc0e9a9fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83dbc153b4d054dfe8ccfec6a0c7adbc"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StorageInterface.html#ga83dbc153b4d054dfe8ccfec6a0c7adbc">bootloader_continueVerifyImage</a> (void *context, <a class="el" href="group__ParserInterface.html#gab0f1ad6d1628b642d6574e191a60df2c">BootloaderParserCallback_t</a> metadataCallback)</td></tr>
<tr class="separator:ga83dbc153b4d054dfe8ccfec6a0c7adbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa292326b7370d02f99702ce3b17b9cfc"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StorageInterface.html#gaa292326b7370d02f99702ce3b17b9cfc">bootloader_verifyImage</a> (uint32_t slotId, <a class="el" href="group__ParserInterface.html#gab0f1ad6d1628b642d6574e191a60df2c">BootloaderParserCallback_t</a> metadataCallback)</td></tr>
<tr class="separator:gaa292326b7370d02f99702ce3b17b9cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67eb1e49eeb811780051441399b0cac0"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StorageInterface.html#ga67eb1e49eeb811780051441399b0cac0">bootloader_getImageInfo</a> (uint32_t slotId, <a class="el" href="group__ApplicationProperties.html#ga1443b85815ddfba3617ce100647e5461">ApplicationData_t</a> *appInfo, uint32_t *bootloaderVersion)</td></tr>
<tr class="separator:ga67eb1e49eeb811780051441399b0cac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60cb9344aa4453edf0bc73f18029d389"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StorageInterface.html#ga60cb9344aa4453edf0bc73f18029d389">bootloader_storageIsBusy</a> (void)</td></tr>
<tr class="separator:ga60cb9344aa4453edf0bc73f18029d389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbd1d9bfd1f9a87cc1599ce0354cb405"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StorageInterface.html#gabbd1d9bfd1f9a87cc1599ce0354cb405">bootloader_readRawStorage</a> (uint32_t address, uint8_t *buffer, size_t length)</td></tr>
<tr class="separator:gabbd1d9bfd1f9a87cc1599ce0354cb405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae70235e890e250a27b93c8ec00bc982e"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StorageInterface.html#gae70235e890e250a27b93c8ec00bc982e">bootloader_writeRawStorage</a> (uint32_t address, uint8_t *buffer, size_t length)</td></tr>
<tr class="separator:gae70235e890e250a27b93c8ec00bc982e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2f888bce5340da23d5febfb94f65017"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StorageInterface.html#gab2f888bce5340da23d5febfb94f65017">bootloader_eraseRawStorage</a> (uint32_t address, size_t length)</td></tr>
<tr class="separator:gab2f888bce5340da23d5febfb94f65017"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gac5a52f72db78d655840177f0e034d37c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__StorageInterface.html#gac5a52f72db78d655840177f0e034d37c">BootloaderStorageType_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Possible storage types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggac5a52f72db78d655840177f0e034d37caaf1113ff5007b46ad4e50ef301ed299b"></a>SPIFLASH&#160;</td><td class="fielddoc">
<p>Storage backend is a SPI flash. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggac5a52f72db78d655840177f0e034d37ca5e341ba74bb0afd21095eabe0f8eba9b"></a>INTERNAL_FLASH&#160;</td><td class="fielddoc">
<p>Storage backend is internal flash. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggac5a52f72db78d655840177f0e034d37caf9a807703d9b9e307e6cde5ac7a63164"></a>CUSTOM_STORAGE&#160;</td><td class="fielddoc">
<p>Storage backend is custom. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="btl__interface__storage_8h_source.html#l00039">39</a> of file <a class="el" href="btl__interface__storage_8h_source.html">btl_interface_storage.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gafc4cc80fcbb0bfea595915b11a6b5828"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bootloader_getStorageInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBootloaderStorageInformation__t.html">BootloaderStorageInformation_t</a> *&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get information about the storage plugin.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>Information about the storage plugin. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga08d0906c70cd68f8119b8f11319cc5ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t bootloader_getStorageSlotInfo </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>slotId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structBootloaderStorageSlot__t.html">BootloaderStorageSlot_t</a> *&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get information about a storage slot.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">slotId</td><td>ID of the slot to get information about </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">slot</td><td>Information about the storage slot.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__ErrorCodes.html#gaf5e631186d857be458f4bdb824db1884">BOOTLOADER_OK</a> on success, else error code in <a class="el" href="group__ErrorBases.html#ga6e7d9953864f32fd1a1121ffd6f1f86e">BOOTLOADER_ERROR_STORAGE_BASE</a> range </dd></dl>

</div>
</div>
<a class="anchor" id="gacd7f4e8b6bba7fd8689a9a2da9511afd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t bootloader_readStorage </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>slotId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data from a storage slot.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">slotId</td><td>ID of the slot </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Offset into the slot to start reading from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>Buffer to store the data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>How much data to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__ErrorCodes.html#gaf5e631186d857be458f4bdb824db1884">BOOTLOADER_OK</a> on success, else error code in <a class="el" href="group__ErrorBases.html#ga6e7d9953864f32fd1a1121ffd6f1f86e">BOOTLOADER_ERROR_STORAGE_BASE</a> range </dd></dl>

</div>
</div>
<a class="anchor" id="ga86dae5018d8726a68dd826240d8f2c52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t bootloader_writeStorage </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>slotId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write data to a storage slot.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">slotId</td><td>ID of the slot </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Offset into the slot to start writing to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Buffer to read data to write from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>How much data to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__ErrorCodes.html#gaf5e631186d857be458f4bdb824db1884">BOOTLOADER_OK</a> on success, else error code in <a class="el" href="group__ErrorBases.html#ga6e7d9953864f32fd1a1121ffd6f1f86e">BOOTLOADER_ERROR_STORAGE_BASE</a> range </dd></dl>

</div>
</div>
<a class="anchor" id="gafec82c0010c632b0c9cecc1cdf393cc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t bootloader_eraseWriteStorage </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>slotId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Erase and write data to a storage slot.</p>
<dl class="section note"><dt>Note</dt><dd>This function automatically erases the following flash page whenever the written data crosses a page boundary. This means that the function cannot be used to perform multiple sequential writes to the same address range unless the range starts at a page boundary. For a sequential write, the first call to this function should have a start address at a page boundary, otherwise the corresponding page of the starting address needs to be erased explicitly.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">slotId</td><td>ID of the slot </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Offset into the slot to start writing to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Buffer to read data to write from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>How much data to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__ErrorCodes.html#gaf5e631186d857be458f4bdb824db1884">BOOTLOADER_OK</a> on success, else error code in <a class="el" href="group__ErrorBases.html#ga6e7d9953864f32fd1a1121ffd6f1f86e">BOOTLOADER_ERROR_STORAGE_BASE</a> range </dd></dl>

</div>
</div>
<a class="anchor" id="gae14880e1483f25bd67f1b96e5345862f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t bootloader_eraseStorageSlot </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>slotId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Erase all contents of a storage slot.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">slotId</td><td>ID of the slot</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__ErrorCodes.html#gaf5e631186d857be458f4bdb824db1884">BOOTLOADER_OK</a> on success, else error code in <a class="el" href="group__ErrorBases.html#ga6e7d9953864f32fd1a1121ffd6f1f86e">BOOTLOADER_ERROR_STORAGE_BASE</a> range </dd></dl>

</div>
</div>
<a class="anchor" id="gaf73aff5099338a5ecf5d38197dfee5d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t bootloader_initChunkedEraseStorageSlot </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>slotId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structBootloaderEraseStatus__t.html">BootloaderEraseStatus_t</a> *&#160;</td>
          <td class="paramname"><em>eraseStat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize chunked erase of a storage slot.</p>
<dl class="section note"><dt>Note</dt><dd>This function must be called before calling <a class="el" href="group__StorageInterface.html#gaa00cc123780c7655385b8c7b6a9f6e31">bootloader_chunkedEraseStorageSlot</a> in a loop.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">slotId</td><td>ID of the slot </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eraseStat</td><td>Erase status struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__ErrorCodes.html#gaf5e631186d857be458f4bdb824db1884">BOOTLOADER_OK</a> on success, else error code in <a class="el" href="group__ErrorBases.html#ga6e7d9953864f32fd1a1121ffd6f1f86e">BOOTLOADER_ERROR_STORAGE_BASE</a> range </dd></dl>

</div>
</div>
<a class="anchor" id="gaa00cc123780c7655385b8c7b6a9f6e31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t bootloader_chunkedEraseStorageSlot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBootloaderEraseStatus__t.html">BootloaderEraseStatus_t</a> *&#160;</td>
          <td class="paramname"><em>eraseStat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Erase one page from a storage slot according to the struct <a class="el" href="structBootloaderEraseStatus__t.html" title="Erase status struct. ">BootloaderEraseStatus_t</a>.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__StorageInterface.html#gaf73aff5099338a5ecf5d38197dfee5d3">bootloader_initChunkedEraseStorageSlot</a> must be called before calling this function, in order to prepare <a class="el" href="structBootloaderEraseStatus__t.html" title="Erase status struct. ">BootloaderEraseStatus_t</a>.</dd>
<dd>
This can be called sequentially to e.g. erase all the contents of a storage slot.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eraseStat</td><td>Erase status struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__StorageError.html#gaeac81825509da898982068a540ac0688">BOOTLOADER_ERROR_STORAGE_CONTINUE</a> if erasing a page was successful. Erase can be continued by calling this function again. <a class="el" href="group__ErrorCodes.html#gaf5e631186d857be458f4bdb824db1884">BOOTLOADER_OK</a> if the entire slot has been erased, else error code in <a class="el" href="group__ErrorBases.html#ga6e7d9953864f32fd1a1121ffd6f1f86e">BOOTLOADER_ERROR_STORAGE_BASE</a> range </dd></dl>

</div>
</div>
<a class="anchor" id="ga8e20baecb19424efaa667248b851d991"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t bootloader_setImagesToBootload </td>
          <td>(</td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>slotIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a prioritized list of images to attempt to bootload. The last call to this function determines which slot will be installed when <a class="el" href="group__CommonInterface.html#ga100dba06fa6561f27e924e6eb56cfa47">bootloader_rebootAndInstall</a> is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">slotIds</td><td>Prioritized list of slot IDs to attempt to bootload. The first image to pass verification will be bootloaded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of the slotIds array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__ErrorCodes.html#gaf5e631186d857be458f4bdb824db1884">BOOTLOADER_OK</a> on success, else error code in <a class="el" href="group__ErrorBases.html#ga492697ebcf2e05f405a905f607332df1">BOOTLOADER_ERROR_BOOTLOAD_BASE</a> range </dd></dl>

</div>
</div>
<a class="anchor" id="gafb9569405337cf6a8bec987bf96705c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t bootloader_getImagesToBootload </td>
          <td>(</td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>slotIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the prioritized list of images the bootloader will attempt to bootload.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">slotIds</td><td>Prioritized list of slot IDs to attempt to bootload. The first image to pass verification will be bootloaded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of the slotIds array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__ErrorCodes.html#gaf5e631186d857be458f4bdb824db1884">BOOTLOADER_OK</a> on success, else error code in <a class="el" href="group__ErrorBases.html#ga492697ebcf2e05f405a905f607332df1">BOOTLOADER_ERROR_BOOTLOAD_BASE</a> range </dd></dl>

</div>
</div>
<a class="anchor" id="ga833f0a3ed32c054d48e564d2fd5082aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t bootloader_appendImageToBootloadList </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>slotId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append a single image to the list of images to attempt to bootload.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">slotId</td><td>ID of the slot to append</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__ErrorCodes.html#gaf5e631186d857be458f4bdb824db1884">BOOTLOADER_OK</a> on success, else error code in <a class="el" href="group__ErrorBases.html#ga492697ebcf2e05f405a905f607332df1">BOOTLOADER_ERROR_BOOTLOAD_BASE</a> range </dd></dl>

</div>
</div>
<a class="anchor" id="gaf4c61349c24dca22a52ba3de71ffe7ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t bootloader_setImageToBootload </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>slotId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a single image to attempt to bootload.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">slotId</td><td>ID of the slot</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__ErrorCodes.html#gaf5e631186d857be458f4bdb824db1884">BOOTLOADER_OK</a> on success, else error code in <a class="el" href="group__ErrorBases.html#ga492697ebcf2e05f405a905f607332df1">BOOTLOADER_ERROR_BOOTLOAD_BASE</a> range </dd></dl>

</div>
</div>
<a class="anchor" id="gad375581d8a53e23db490a4bc0e9a9fb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t bootloader_initVerifyImage </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>slotId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>contextSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize image verification.</p>
<p>Initialize verification of an upgrade image stored in a bootloader storage slot.</p>
<dl class="section note"><dt>Note</dt><dd>This function must be called before calling <a class="el" href="group__StorageInterface.html#ga83dbc153b4d054dfe8ccfec6a0c7adbc">bootloader_continueVerifyImage</a> in a loop.</dd>
<dd>
The context pointer must point to memory allocated by the caller. The required size of this context may depend on the version of the bootloader. The required size for the bootloader associated with this version of the application interface is given by the define <a class="el" href="group__StorageInterface.html#ga1775031079e1d33177fe3ac48a732336">BOOTLOADER_STORAGE_VERIFICATION_CONTEXT_SIZE</a>.</dd>
<dd>
Instead of calling <a class="el" href="group__StorageInterface.html#gad375581d8a53e23db490a4bc0e9a9fb2">bootloader_initVerifyImage</a> followed by <a class="el" href="group__StorageInterface.html#ga83dbc153b4d054dfe8ccfec6a0c7adbc">bootloader_continueVerifyImage</a>, a single call to <a class="el" href="group__StorageInterface.html#gaa292326b7370d02f99702ce3b17b9cfc">bootloader_verifyImage</a> can be performed if the caller doesn't have any time-critical tasks to attend to, and has sufficient stack space for the automatically allocated context. The purpose of the init-and-continue functions is to allow the caller to service system needs during verification.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">slotId</td><td>Id of the slot to check. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">context</td><td>Pointer to memory used to hold the parser context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">contextSize</td><td>Size of the context. An error is returned if the supplied context is too small.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__ErrorCodes.html#gaf5e631186d857be458f4bdb824db1884">BOOTLOADER_OK</a> if the image parser was initialized, else error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ga83dbc153b4d054dfe8ccfec6a0c7adbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t bootloader_continueVerifyImage </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ParserInterface.html#gab0f1ad6d1628b642d6574e191a60df2c">BootloaderParserCallback_t</a>&#160;</td>
          <td class="paramname"><em>metadataCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Continue image verification.</p>
<p>Continue verification of an upgrade image stored in a bootloader storage slot.</p>
<dl class="section note"><dt>Note</dt><dd>This function must be called in a loop until anything other than <a class="el" href="group__ParseErrpr.html#gab13b4da5c5b50b81cbd699c61b2efab7">BOOTLOADER_ERROR_PARSE_CONTINUE</a> is returned.</dd>
<dd>
<a class="el" href="group__StorageInterface.html#gad375581d8a53e23db490a4bc0e9a9fb2">bootloader_initVerifyImage</a> must be called before calling this function, in order to reset the parser.</dd>
<dd>
Instead of calling <a class="el" href="group__StorageInterface.html#gad375581d8a53e23db490a4bc0e9a9fb2">bootloader_initVerifyImage</a> followed by <a class="el" href="group__StorageInterface.html#ga83dbc153b4d054dfe8ccfec6a0c7adbc">bootloader_continueVerifyImage</a>, a single call to <a class="el" href="group__StorageInterface.html#gaa292326b7370d02f99702ce3b17b9cfc">bootloader_verifyImage</a> can be performed if the caller doesn't have any time-critical tasks to attend to. The purpose of the init-and-continue functions is to allow the caller to service system needs during verification.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">context</td><td>Pointer to context structure that has previously been initialized by calling <a class="el" href="group__StorageInterface.html#gad375581d8a53e23db490a4bc0e9a9fb2">bootloader_initVerifyImage()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">metadataCallback</td><td>Function pointer which gets called when there is binary metadata present in the image being verified. Set to NULL if not required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__ParseErrpr.html#gab13b4da5c5b50b81cbd699c61b2efab7">BOOTLOADER_ERROR_PARSE_CONTINUE</a> if parsing was successful, and the parser expects more data. <a class="el" href="group__ParseErrpr.html#ga22675de53139d1378f7be438a06c66d4">BOOTLOADER_ERROR_PARSE_SUCCESS</a> if the parser has successfully parsed the image and it passes verification. Else error code. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa292326b7370d02f99702ce3b17b9cfc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t bootloader_verifyImage </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>slotId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ParserInterface.html#gab0f1ad6d1628b642d6574e191a60df2c">BootloaderParserCallback_t</a>&#160;</td>
          <td class="paramname"><em>metadataCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Verify that the image in the given storage slot is valid</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">slotId</td><td>Id of the slot to check </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">metadataCallback</td><td>Function pointer which gets called when there is binary metadata present in the storage slot. Set to NULL if not required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function will allocate a context structure of the size given by <a class="el" href="group__StorageInterface.html#ga1775031079e1d33177fe3ac48a732336">BOOTLOADER_STORAGE_VERIFICATION_CONTEXT_SIZE</a> on the caller's stack. If the caller prefers to manage its own memory, and allocate the context elsewhere (on the heap, as a global variable, etc), use the <a class="el" href="group__StorageInterface.html#gad375581d8a53e23db490a4bc0e9a9fb2">bootloader_initVerifyImage</a> and <a class="el" href="group__StorageInterface.html#ga83dbc153b4d054dfe8ccfec6a0c7adbc">bootloader_continueVerifyImage</a> functions instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__ErrorCodes.html#gaf5e631186d857be458f4bdb824db1884">BOOTLOADER_OK</a> if the image is valid, else error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ga67eb1e49eeb811780051441399b0cac0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t bootloader_getImageInfo </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>slotId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ApplicationProperties.html#ga1443b85815ddfba3617ce100647e5461">ApplicationData_t</a> *&#160;</td>
          <td class="paramname"><em>appInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>bootloaderVersion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get application and bootloader upgrade metadata from storage slot</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">slotId</td><td>Id of the slot to check </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">appInfo</td><td>Pointer to <a class="el" href="group__ApplicationProperties.html#ga1443b85815ddfba3617ce100647e5461">ApplicationData_t</a> struct </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bootloaderVersion</td><td>Pointer to integer representing bootloader version</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__ErrorCodes.html#gaf5e631186d857be458f4bdb824db1884">BOOTLOADER_OK</a> if metadata was filled successfully </dd></dl>

</div>
</div>
<a class="anchor" id="ga60cb9344aa4453edf0bc73f18029d389"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bootloader_storageIsBusy </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether the bootloader storage is busy</p>
<dl class="section return"><dt>Returns</dt><dd>True if the storage is busy </dd></dl>

</div>
</div>
<a class="anchor" id="gabbd1d9bfd1f9a87cc1599ce0354cb405"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t bootloader_readRawStorage </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read raw data from storage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Address to start reading from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>Buffer to store the data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>How much data to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__ErrorCodes.html#gaf5e631186d857be458f4bdb824db1884">BOOTLOADER_OK</a> on success, else error code in <a class="el" href="group__ErrorBases.html#ga6e7d9953864f32fd1a1121ffd6f1f86e">BOOTLOADER_ERROR_STORAGE_BASE</a> range </dd></dl>

</div>
</div>
<a class="anchor" id="gae70235e890e250a27b93c8ec00bc982e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t bootloader_writeRawStorage </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write data to storage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Address to start writing to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Buffer to read data to write from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>How much data to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__ErrorCodes.html#gaf5e631186d857be458f4bdb824db1884">BOOTLOADER_OK</a> on success, else error code in <a class="el" href="group__ErrorBases.html#ga6e7d9953864f32fd1a1121ffd6f1f86e">BOOTLOADER_ERROR_STORAGE_BASE</a> range </dd></dl>

</div>
</div>
<a class="anchor" id="gab2f888bce5340da23d5febfb94f65017"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t bootloader_eraseRawStorage </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Erase data from storage.</p>
<dl class="section note"><dt>Note</dt><dd>Erasing storage must adhere to the limitiations of the underlying storage medium, such as requiring full page erases. Use <a class="el" href="group__StorageInterface.html#gafc4cc80fcbb0bfea595915b11a6b5828">bootloader_getStorageInfo</a> to learn the limitiations of the configured storage medium.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Address to start erasing from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of data to erase</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__ErrorCodes.html#gaf5e631186d857be458f4bdb824db1884">BOOTLOADER_OK</a> on success, else error code in <a class="el" href="group__ErrorBases.html#ga6e7d9953864f32fd1a1121ffd6f1f86e">BOOTLOADER_ERROR_STORAGE_BASE</a> range </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Mar 5 2019 08:24:17 for Gecko Bootloader API Reference by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
